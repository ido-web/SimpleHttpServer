
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>typing --- 类型标注支持 &#8212; Python 3.7.3 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.7.3 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="pydoc --- Documentation generator and online help system" href="pydoc.html" />
    <link rel="prev" title="开发工具" href="development.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- Documentation generator and online help system"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">开发工具</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see PEP 484)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> --- 类型标注支持<a class="headerlink" href="#module-typing" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>typing 模块以 <a class="reference internal" href="../glossary.html#term-provisional-api"><span class="xref std std-term">暂定状态</span></a> 包含在标准库中。如果核心开发人员认为有必要，可能会添加新功能，甚至可能会在次要版本之间改变 API。</p>
</div>
<hr class="docutils" />
<p>此模块支持 <span class="target" id="index-16"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 和 <span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 指定的类型提示。最基本的支持由 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，<a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>，<a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>，<a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>，<a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 和 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 类型组成。有关完整的规范，请参阅 <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。有关类型提示的简单介绍，请参阅 <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>。</p>
<p>函数接受并返回一个字符串，注释像下面这样:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>在函数 <code class="docutils literal notranslate"><span class="pre">greeting</span></code> 中，参数 <code class="docutils literal notranslate"><span class="pre">name</span></code> 预期是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型，并且返回 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型。子类型允许作为参数。</p>
<div class="section" id="type-aliases">
<h2>类型别名<a class="headerlink" href="#type-aliases" title="永久链接至标题">¶</a></h2>
<p>类型别名通过将类型分配给别名来定义。在这个例子中， <code class="docutils literal notranslate"><span class="pre">Vector</span></code> 和 <code class="docutils literal notranslate"><span class="pre">List[float]</span></code> 将被视为可互换的同义词:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span>
<span class="n">Vector</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># typechecks; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>类型别名可用于简化复杂类型签名。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>请注意，<code class="docutils literal notranslate"><span class="pre">None</span></code> 作为类型提示是一种特殊情况，并且由 <code class="docutils literal notranslate"><span class="pre">type(None)</span></code> 取代。</p>
</div>
<div class="section" id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="永久链接至标题">¶</a></h2>
<p>使用 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a> 辅助函数创建不同的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>静态类型检查器会将新类型视为它是原始类型的子类。这对于帮助捕捉逻辑错误非常有用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># typechecks</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># does not typecheck; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>您仍然可以对 <code class="docutils literal notranslate"><span class="pre">UserId</span></code> 类型的变量执行所有的 <code class="docutils literal notranslate"><span class="pre">int</span></code> 支持的操作，但结果将始终为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型。这可以让你在需要 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的地方传入 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>，但会阻止你以无效的方式无意中创建 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意，这些检查仅通过静态类型检查程序强制执行。在运行时，<code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived'，Base)</span></code> 将 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 一个函数，该函数立即返回您传递它的任何参数。这意味着表达式 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 不会创建一个新的类或引入任何超出常规函数调用的开销。</p>
<p>更确切地说，表达式 <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> 在运行时总是为真。</p>
<p>这也意味着无法创建 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的子类型，因为它是运行时的标识函数，而不是实际的类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not typecheck</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>但是，可以基于'derived' <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 创建 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>并且 <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> 的类型检查将按预期工作。</p>
<p>有关更多详细信息，请参阅 <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>回想一下，使用类型别名声明两种类型彼此 <em>等效</em> 。<code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> 将使静态类型检查对待所有情况下 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> <em>完全等同于</em> <code class="docutils literal notranslate"><span class="pre">Original</span></code>。当您想简化复杂类型签名时，这很有用。</p>
<p>相反，<code class="docutils literal notranslate"><span class="pre">NewType</span></code> 声明一种类型是另一种类型的子类型。<code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> 将使静态类型检查器将 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 当作 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的 <em>子类</em> ，这意味着 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 类型的值不能用于 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 类型的值需要的地方。当您想以最小的运行时间成本防止逻辑错误时，这非常有用。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</div>
<div class="section" id="callable">
<h2>Callable<a class="headerlink" href="#callable" title="永久链接至标题">¶</a></h2>
<p>期望特定签名的回调函数的框架可以将类型标注为 <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code>。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
</pre></div>
</div>
<p>通过用文字省略号替换类型提示中的参数列表： <code class="docutils literal notranslate"><span class="pre">Callable[...，ReturnType]</span></code>，可以声明可调用的返回类型，而无需指定调用签名。</p>
</div>
<div class="section" id="generics">
<span id="id1"></span><h2>泛型(Generic)<a class="headerlink" href="#generics" title="永久链接至标题">¶</a></h2>
<p>由于无法以通用方式静态推断有关保存在容器中的对象的类型信息，因此抽象基类已扩展为支持订阅以表示容器元素的预期类型。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>泛型可以通过使用typing模块中名为 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 的新工厂进行参数化。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="user-defined-generic-types">
<h2>用户定义的泛型类型<a class="headerlink" href="#user-defined-generic-types" title="永久链接至标题">¶</a></h2>
<p>用户定义的类可以定义为泛型类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code> 作为基类定义了类 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> 采用单个类型参数 <code class="docutils literal notranslate"><span class="pre">T</span></code>。这也使得 <code class="docutils literal notranslate"><span class="pre">T</span></code> 作为类体内的一个类型有效。</p>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 基类使用定义了 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 的元类，以便 <code class="docutils literal notranslate"><span class="pre">LoggedVar[t]</span></code> 作为类型有效:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>泛型类型可以有任意数量的类型变量，并且类型变量可能会受到限制:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StrangePair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 每个参数的类型变量必须是不同的。这是无效的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>您可以对 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 使用多重继承:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sized</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>从泛型类继承时，某些类型变量可能是固定的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>在这种情况下，<code class="docutils literal notranslate"><span class="pre">MyDict</span></code> 只有一个参数，<code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>在不指定类型参数的情况下使用泛型类别会为每个位置假设 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。在下面的例子中，<code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> 不是泛型，但是隐式继承自 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</pre></div>
</div>
<p>用户定义的通用类型别名也受支持。例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>

<span class="c1"># Return type here is same as Union[Iterable[str], int]</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[Tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 使用的元类是 <a class="reference internal" href="abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> 的子类。泛型类可以通过包含抽象方法或属性成为ABC，并且泛型类也可以使用ABCs作为基类而不存在元类冲突。不支持泛型元类。参数化泛型的结果被缓存，并且typing模块中的大部分类型都是可散列的，并且可以比较是否相等。</p>
</div>
<div class="section" id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型<a class="headerlink" href="#the-any-type" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 是一种特殊的类型。静态类型检查器将所有类型视为与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容，反之亦然， <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 也与所有类型相兼容。</p>
<p>这意味着可对类型为 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 的值执行任何操作或方法调用，并将其赋值给任何变量:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span>

<span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>    <span class="c1"># type: Any</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>       <span class="c1"># OK</span>

<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>      <span class="c1"># type: str</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>       <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>需要注意的是，将 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值赋值给另一个更具体的类型时，Python不会执行类型检查。例如，当把 <code class="docutils literal notranslate"><span class="pre">a</span></code> 赋值给 <code class="docutils literal notranslate"><span class="pre">s</span></code> 时，即使 <code class="docutils literal notranslate"><span class="pre">s</span></code> 被声明为 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型，在运行时接收到的是 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 值，静态类型检查器也不会报错。</p>
<p>此外，所有返回值无类型或形参无类型的函数将隐式地默认使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>当需要混用动态类型和静态类型的代码时，上述行为可以让 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 被用作 <em>应急出口</em> 。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 和 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的行为对比。与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相似，所有的类型都是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的子类型。然而不同于 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，反之并不成立： <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>不是</em> 其他所有类型的子类型。</p>
<p>这意味着当一个值的类型是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的时候，类型检查器会拒绝对它的几乎所有的操作。把它赋值给一个指定了类型的变量（或者当作返回值）是一个类型错误。比如说：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Typechecks, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Typechecks, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 示意一个值可以类型安全地兼容任何类型。使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 示意一个值地类型是动态定义的。</p>
</div>
<div class="section" id="classes-functions-and-decorators">
<h2>类,函数和修饰器.<a class="headerlink" href="#classes-functions-and-decorators" title="永久链接至标题">¶</a></h2>
<p>这个模块定义了如下的类,模块和修饰器.</p>
<dl class="class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="永久链接至目标">¶</a></dt>
<dd><p>类型变量</p>
<p>用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be str or bytes</span>
</pre></div>
</div>
<p>Type variables exist primarily for the benefit of static type
checkers.  They serve as the parameters for generic types as well
as for generic function definitions.  See class Generic for more
information on generic types.  Generic functions work as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>

<span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the longest of two strings.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>The latter example's signature is essentially the overloading
of <code class="docutils literal notranslate"><span class="pre">(str,</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></code> and <code class="docutils literal notranslate"><span class="pre">(bytes,</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></code>.  Also note
that if the arguments are instances of some subclass of <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
the return type is still plain <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> 会在运行时抛出 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。一般地说， <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 不应该和类型一起使用。</p>
<p>Type variables may be marked covariant or contravariant by passing
<code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> or <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>.  See <span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> for more
details.  By default type variables are invariant.  Alternatively,
a type variable may specify an upper bound using <code class="docutils literal notranslate"><span class="pre">bound=&lt;type&gt;</span></code>.
This means that an actual type substituted (explicitly or implicitly)
for the type variable must be a subclass of the boundary type,
see <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Generic">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generic</code><a class="headerlink" href="#typing.Generic" title="永久链接至目标">¶</a></dt>
<dd><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from an
instantiation of this class with one or more type variables.
For example, a generic mapping type might be defined as:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>这个类之后可以被这样用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Type">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Type</code><span class="sig-paren">(</span><em>Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="永久链接至目标">¶</a></dt>
<dd><p>A variable annotated with <code class="docutils literal notranslate"><span class="pre">C</span></code> may accept a value of type <code class="docutils literal notranslate"><span class="pre">C</span></code>. In
contrast, a variable annotated with <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> may accept values that are
classes themselves -- specifically, it will accept the <em>class object</em> of
<code class="docutils literal notranslate"><span class="pre">C</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type &#39;int&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type &#39;Type[int]&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type &#39;Type[int]&#39;</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> is covariant:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># Accepts User, BasicUser, ProUser, TeamUser, ...</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p>The fact that <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> is covariant implies that all subclasses of
<code class="docutils literal notranslate"><span class="pre">C</span></code> should implement the same constructor signature and class method
signatures as <code class="docutils literal notranslate"><span class="pre">C</span></code>. The type checker should flag violations of this,
but should also allow constructor calls in subclasses that match the
constructor calls in the indicated base class. How the type checker is
required to handle this particular case may change in future revisions of
<span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>.</p>
<p>The only legal parameters for <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a> are classes, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>,
<a class="reference internal" href="#generics"><span class="std std-ref">type variables</span></a>, and unions of any of these types.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BaseUser</span><span class="p">,</span> <span class="n">ProUser</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">Type</span></code> which in turn is equivalent
to <code class="docutils literal notranslate"><span class="pre">type</span></code>, which is the root of Python's metaclass hierarchy.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Iterator</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Reversible</code><span class="sig-paren">(</span><em>Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__int__</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__float__</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__abs__</span></code> that is covariant
in its return type.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="永久链接至目标">¶</a></dt>
<dd><p>An ABC with one abstract method <code class="docutils literal notranslate"><span class="pre">__round__</span></code>
that is covariant in its return type.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Container">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Container</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> 的别名。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sized">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sized</code><a class="headerlink" href="#typing.Sized" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> 的别名。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Collection">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Collection</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AbstractSet</code><span class="sig-paren">(</span><em>Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>  的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSet</code><span class="sig-paren">(</span><em>AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的泛型版本。这个类型可以如下使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableMapping</code><span class="sig-paren">(</span><em>Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Sequence</code><span class="sig-paren">(</span><em>Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MutableSequence</code><span class="sig-paren">(</span><em>Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ByteString</code><span class="sig-paren">(</span><em>Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a> 的泛型版本。</p>
<p>This type represents the types <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>,
and <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>.</p>
<p>As a shorthand for this type, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> can be used to
annotate arguments of any of the types mentioned above.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Deque">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Deque</code><span class="sig-paren">(</span><em>deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.List">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">List</code><span class="sig-paren">(</span><em>list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="永久链接至目标">¶</a></dt>
<dd><p>Generic version of <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>.
Useful for annotating return types. To annotate arguments it is preferred
to use an abstract collection type such as <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> or
<a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>.</p>
<p>这个类型可以这样用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Set">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Set</code><span class="sig-paren">(</span><em>set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="永久链接至目标">¶</a></dt>
<dd><p>A generic version of <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>.
Useful for annotating return types. To annotate arguments it is preferred
to use an abstract collection type such as <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">FrozenSet</code><span class="sig-paren">(</span><em>frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="永久链接至目标">¶</a></dt>
<dd><p>A generic version of <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">MappingView</code><span class="sig-paren">(</span><em>Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">KeysView</code><span class="sig-paren">(</span><em>MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ItemsView</code><span class="sig-paren">(</span><em>MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ValuesView</code><span class="sig-paren">(</span><em>MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Awaitable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Coroutine</code><span class="sig-paren">(</span><em>Awaitable[V_co], Generic[T_co T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="永久链接至目标">¶</a></dt>
<dd><p>A generic version of <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>.
The variance and order of type variables
correspond to those of <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, for example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Coroutine</span>
<span class="n">c</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># type: Coroutine[List[str], str, int]</span>
<span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span> <span class="c1"># type: List[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span> <span class="c1"># type: int</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterable</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncIterator</code><span class="sig-paren">(</span><em>AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 的泛型版本。</p>
</dd></dl>

<dl class="class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ContextManager</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncContextManager">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncContextManager</code><span class="sig-paren">(</span><em>Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Dict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Dict</code><span class="sig-paren">(</span><em>dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的泛型版本。对标注返回类型比较有用。如果要标注参数的话，使用如 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 的抽象容器类型是更好的选择。</p>
<p>这个类型可以这样使用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">DefaultDict</code><span class="sig-paren">(</span><em>collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.OrderedDict">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">OrderedDict</code><span class="sig-paren">(</span><em>collections.OrderedDict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Counter">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Counter</code><span class="sig-paren">(</span><em>collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">ChainMap</code><span class="sig-paren">(</span><em>collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Generator</code><span class="sig-paren">(</span><em>Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="永久链接至目标">¶</a></dt>
<dd><p>A generator can be annotated by the generic type
<code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>Note that unlike many other generics in the typing module, the <code class="docutils literal notranslate"><span class="pre">SendType</span></code>
of <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> behaves contravariantly, not covariantly or
invariantly.</p>
<p>If your generator will only yield values, set the <code class="docutils literal notranslate"><span class="pre">SendType</span></code> and
<code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> to <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Alternatively, annotate your generator as having a return type of
either <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code> or <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">AsyncGenerator</code><span class="sig-paren">(</span><em>AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="永久链接至目标">¶</a></dt>
<dd><p>An async generator can be annotated by the generic type
<code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>Unlike normal generators, async generators cannot return a value, so there
is no <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> type parameter. As with <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">SendType</span></code> behaves contravariantly.</p>
<p>If your generator will only yield values, set the <code class="docutils literal notranslate"><span class="pre">SendType</span></code> to
<code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, annotate your generator as having a return type of
either <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code> or <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Text">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Text</code><a class="headerlink" href="#typing.Text" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">str</span></code>. It is provided to supply a forward
compatible path for Python 2 code: in Python 2, <code class="docutils literal notranslate"><span class="pre">Text</span></code> is an alias for
<code class="docutils literal notranslate"><span class="pre">unicode</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">Text</span></code> to indicate that a value must contain a unicode string in
a manner that is compatible with both Python 2 and Python 3:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.IO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">IO</code><a class="headerlink" href="#typing.IO" title="永久链接至目标">¶</a></dt>
<dt id="typing.TextIO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">TextIO</code><a class="headerlink" href="#typing.TextIO" title="永久链接至目标">¶</a></dt>
<dt id="typing.BinaryIO">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">BinaryIO</code><a class="headerlink" href="#typing.BinaryIO" title="永久链接至目标">¶</a></dt>
<dd><p>Generic type <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> and its subclasses <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>
and <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>
represent the types of I/O streams such as returned by
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Pattern">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Pattern</code><a class="headerlink" href="#typing.Pattern" title="永久链接至目标">¶</a></dt>
<dt id="typing.Match">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">Match</code><a class="headerlink" href="#typing.Match" title="永久链接至目标">¶</a></dt>
<dd><p>These type aliases
correspond to the return types from <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> and
<a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>.  These types (and the corresponding functions)
are generic in <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> and can be made specific by writing
<code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code>, or
<code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="descclassname">typing.</code><code class="descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="永久链接至目标">¶</a></dt>
<dd><p>Typed version of <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.</p>
<p>用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>To give a field a default value, you can assign to it in the class body:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Fields with a default value must come after any fields without a default.</p>
<p>The resulting class has two extra attributes: <code class="docutils literal notranslate"><span class="pre">_field_types</span></code>,
giving a dict mapping field names to types, and <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code>, a dict
mapping field names to default values.  (The field names are in the
<code class="docutils literal notranslate"><span class="pre">_fields</span></code> attribute, which is part of the namedtuple API.)</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> subclasses can also have docstrings and methods:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{self.name}</span><span class="s1">, id=</span><span class="si">{self.id}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>Backward-compatible usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>Added support for <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> variable annotation syntax.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6.1 版更改: </span>Added support for default values, methods, and docstrings.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.NewType">
<code class="descclassname">typing.</code><code class="descname">NewType</code><span class="sig-paren">(</span><em>typ</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="永久链接至目标">¶</a></dt>
<dd><p>A helper function to indicate a distinct types to a typechecker,
see <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>. At runtime it returns a function that returns
its argument. Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.cast">
<code class="descclassname">typing.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>typ</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="永久链接至目标">¶</a></dt>
<dd><p>Cast a value to a type.</p>
<p>This returns the value unchanged.  To the type checker this
signals that the return value has the designated type, but at
runtime we intentionally don't check anything (we want this
to be as fast as possible).</p>
</dd></dl>

<dl class="function">
<dt id="typing.get_type_hints">
<code class="descclassname">typing.</code><code class="descname">get_type_hints</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个字典，字典内含有函数、方法、模块或类对象的类型提示。</p>
<p>This is often the same as <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>. In addition,
forward references encoded as string literals are handled by evaluating
them in <code class="docutils literal notranslate"><span class="pre">globals</span></code> and <code class="docutils literal notranslate"><span class="pre">locals</span></code> namespaces. If necessary,
<code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code> is added for function and method annotations if a default
value equal to <code class="docutils literal notranslate"><span class="pre">None</span></code> is set. For a class <code class="docutils literal notranslate"><span class="pre">C</span></code>, return
a dictionary constructed by merging all the <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> along
<code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code> in reverse order.</p>
</dd></dl>

<dl class="function">
<dt id="typing.overload">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">overload</code><a class="headerlink" href="#typing.overload" title="永久链接至目标">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> decorator allows describing functions and methods
that support multiple different combinations of argument types. A series
of <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions must be followed by exactly one
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition (for the same function/method).
The <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definitions are for the benefit of the
type checker only, since they will be overwritten by the
non-<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated definition, while the latter is used at
runtime but should be ignored by a type checker.  At runtime, calling
a <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-decorated function directly will raise
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. An example of overload that gives a more
precise type than can be expressed using a union or a type variable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>See <span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> for details and comparison with other typing semantics.</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="永久链接至目标">¶</a></dt>
<dd><p>用于指明标注不是类型提示的装饰器。</p>
<p>此 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> 装饰器生效于类或函数上。如果作用于类上的话，它会递归地作用于这个类的所定义的所有方法上（但是对于超类或子类所定义的方法不会生效）。</p>
<p>此方法会就地地修改函数。</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check_decorator">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="永久链接至目标">¶</a></dt>
<dd><p>使其它装饰器起到 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 效果的装饰器。</p>
<p>This wraps the decorator with something that wraps the decorated
function in <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="typing.type_check_only">
<code class="descclassname">&#64;</code><code class="descclassname">typing.</code><code class="descname">type_check_only</code><a class="headerlink" href="#typing.type_check_only" title="永久链接至目标">¶</a></dt>
<dd><p>标记一个类或函数在运行时内不可用的装饰器。</p>
<p>This decorator is itself not available at runtime. It is mainly
intended to mark classes that are defined in type stub files if
an implementation returns an instance of a private class:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Note that returning instances of private classes is not recommended.
It is usually preferable to make such classes public.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Any">
<code class="descclassname">typing.</code><code class="descname">Any</code><a class="headerlink" href="#typing.Any" title="永久链接至目标">¶</a></dt>
<dd><p>特殊类型，表明类型没有任何限制。</p>
<ul class="simple">
<li><p>每一个类型都对 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容。</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 对每一个类型都兼容。</p></li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.NoReturn">
<code class="descclassname">typing.</code><code class="descname">NoReturn</code><a class="headerlink" href="#typing.NoReturn" title="永久链接至目标">¶</a></dt>
<dd><p>标记一个函数没有返回值的特殊类型。比如说:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Union">
<code class="descclassname">typing.</code><code class="descname">Union</code><a class="headerlink" href="#typing.Union" title="永久链接至目标">¶</a></dt>
<dd><p>联合类型； <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> 意味着：要不是 X，要不是 Y。</p>
<p>使用形如 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> 的形式来定义一个联合类型。细节如下:</p>
<ul>
<li><p>参数必须是类型，而且必须至少有一个参数。</p></li>
<li><p>联合类型的联合类型会被展开打平，比如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>仅有一个参数的联合类型会坍缩成参数自身，比如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>多余的参数会被跳过，比如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>在比较联合类型的时候，参数顺序会被忽略，比如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>你不能继承或者实例化一个联合类型。</p></li>
<li><p>你不能写成 <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code> 。</p></li>
<li><p>你可以使用 <code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> 的缩写。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>不要在运行时内从联合类型中移除显式说明的子类。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Optional">
<code class="descclassname">typing.</code><code class="descname">Optional</code><a class="headerlink" href="#typing.Optional" title="永久链接至目标">¶</a></dt>
<dd><p>Optional type.</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>.</p>
<p>Note that this is not the same concept as an optional argument,
which is one that has a default.  An optional argument with a
default does not require the <code class="docutils literal notranslate"><span class="pre">Optional</span></code> qualifier on its type
annotation just because it is optional. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>On the other hand, if an explicit value of <code class="docutils literal notranslate"><span class="pre">None</span></code> is allowed, the
use of <code class="docutils literal notranslate"><span class="pre">Optional</span></code> is appropriate, whether the argument is optional
or not. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Tuple">
<code class="descclassname">typing.</code><code class="descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="永久链接至目标">¶</a></dt>
<dd><p>Tuple type; <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code> is the type of a tuple of two items
with the first item of type X and the second of type Y.</p>
<p>Example: <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code> is a tuple of two elements corresponding
to type variables T1 and T2.  <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code> is a tuple
of an int, a float and a string.</p>
<p>To specify a variable-length tuple of homogeneous type,
use literal ellipsis, e.g. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>. A plain <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>
is equivalent to <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code>, and in turn to <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="typing.Callable">
<code class="descclassname">typing.</code><code class="descname">Callable</code><a class="headerlink" href="#typing.Callable" title="永久链接至目标">¶</a></dt>
<dd><p>Callable type; <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> is a function of (int) -&gt; str.</p>
<p>The subscription syntax must always be used with exactly two
values: the argument list and the return type.  The argument list
must be a list of types or an ellipsis; the return type must be
a single type.</p>
<p>There is no syntax to indicate optional or keyword arguments;
such function types are rarely used as callback types.
<code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code> (literal ellipsis) can be used to
type hint a callable taking any number of arguments and returning
<code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>.  A plain <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>, and in turn to
<a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="typing.ClassVar">
<code class="descclassname">typing.</code><code class="descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="永久链接至目标">¶</a></dt>
<dd><p>Special type construct to mark class variables.</p>
<p>As introduced in <span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, a variable annotation wrapped in ClassVar
indicates that a given attribute is intended to be used as a class variable
and should not be set on instances of that class. Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> accepts only types and cannot be further subscribed.</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> is not a class itself, and should not
be used with <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> or <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.
<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> does not change Python runtime behavior, but
it can be used by third-party type checkers. For example, a type checker
might flag the following code as an error:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.AnyStr">
<code class="descclassname">typing.</code><code class="descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> is a type variable defined as
<code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code>.</p>
<p>It is meant to be used for functions that may accept any kind of string
without allowing different kinds of strings to mix. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.TYPE_CHECKING">
<code class="descclassname">typing.</code><code class="descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="永久链接至目标">¶</a></dt>
<dd><p>A special constant that is assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> by 3rd party static
type checkers. It is <code class="docutils literal notranslate"><span class="pre">False</span></code> at runtime. Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the first type annotation must be enclosed in quotes, making it a
&quot;forward reference&quot;, to hide the <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> reference from the
interpreter runtime.  Type annotations for local variables are not
evaluated, so the second annotation does not need to be enclosed in quotes.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> --- 类型标注支持</a><ul>
<li><a class="reference internal" href="#type-aliases">类型别名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">泛型(Generic)</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">用户定义的泛型类型</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 类型</a></li>
<li><a class="reference internal" href="#classes-functions-and-decorators">类,函数和修饰器.</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="development.html"
                        title="上一章">开发工具</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="pydoc.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- Documentation generator and online help system</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.7/Doc/library/typing.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- Documentation generator and online help system"
             >下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >开发工具</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2019, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    最后更新于 5月 30, 2019.
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>2.0.1 创建。
    </div>

  </body>
</html>