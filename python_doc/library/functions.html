
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>内置函数 &#8212; Python 3.7.3 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.7.3 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="内置常量" href="constants.html" />
    <link rel="prev" title="概述" href="intro.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/functions.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="内置常量"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="概述"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 标准库</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="built-in-functions">
<span id="built-in-funcs"></span><h1>内置函数<a class="headerlink" href="#built-in-functions" title="永久链接至标题">¶</a></h1>
<p>Python 解释器内置了很多函数和类型，您可以在任何时候使用它们。以下按字母表顺序列出它们。</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 21%" />
<col style="width: 18%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head"><p>内置函数</p></th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></p></td>
<td><p><a class="reference internal" href="#delattr" title="delattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">delattr()</span></code></a></p></td>
<td><p><a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-memoryview"><code class="docutils literal notranslate"><span class="pre">memoryview()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-set"><code class="docutils literal notranslate"><span class="pre">set()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-dict"><code class="docutils literal notranslate"><span class="pre">dict()</span></code></a></p></td>
<td><p><a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a></p></td>
<td><p><a class="reference internal" href="#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a></p></td>
<td><p><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></p></td>
<td><p><a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a></p></td>
<td><p><a class="reference internal" href="#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a></p></td>
<td><p><a class="reference internal" href="#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a></p></td>
<td><p><a class="reference internal" href="#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a></p></td>
<td><p><a class="reference internal" href="#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></p></td>
<td><p><a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a></p></td>
<td><p><a class="reference internal" href="#object" title="object"><code class="xref py py-func docutils literal notranslate"><span class="pre">object()</span></code></a></p></td>
<td><p><a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a></p></td>
<td><p><a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a></p></td>
<td><p><a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a></p></td>
<td><p><a class="reference internal" href="#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a></p></td>
<td><p><a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a></p></td>
<td><p><a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a></p></td>
<td><p><a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></p></td>
<td><p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-str"><code class="docutils literal notranslate"><span class="pre">str()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a></p></td>
<td><p><a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a></p></td>
<td><p><a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a></p></td>
<td><p><a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a></p></td>
<td><p><a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#func-bytearray"><code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></a></p></td>
<td><p><a class="reference internal" href="#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a></p></td>
<td><p><a class="reference internal" href="#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a></p></td>
<td><p><a class="reference internal" href="#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></p></td>
<td><p><a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#func-bytes"><code class="docutils literal notranslate"><span class="pre">bytes()</span></code></a></p></td>
<td><p><a class="reference internal" href="#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></p></td>
<td><p><a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a></p></td>
<td><p><a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-tuple"><code class="docutils literal notranslate"><span class="pre">tuple()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a></p></td>
<td><p><a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a></p></td>
<td><p><a class="reference internal" href="#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a></p></td>
<td><p><a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a></p></td>
<td><p><a class="reference internal" href="#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-frozenset"><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-list"><code class="docutils literal notranslate"><span class="pre">list()</span></code></a></p></td>
<td><p><a class="reference internal" href="#func-range"><code class="docutils literal notranslate"><span class="pre">range()</span></code></a></p></td>
<td><p><a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a></p></td>
<td><p><a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a></p></td>
<td><p><a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a></p></td>
<td><p><a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a></p></td>
<td><p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a></p></td>
<td><p><a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a></p></td>
<td><p><a class="reference internal" href="#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a></p></td>
<td><p><a class="reference internal" href="#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a></p></td>
<td><p><a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></p></td>
<td><p><a class="reference internal" href="#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a></p></td>
<td><p><a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a></p></td>
<td><p><a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。</p>
</dd></dl>

<dl class="function">
<dt id="all">
<code class="descname">all</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#all" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>iterable</em> 的所有元素为真（或迭代器为空），返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="any">
<code class="descname">any</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#any" title="永久链接至目标">¶</a></dt>
<dd><p>如果*iterable*的任一元素为真则返回``True``。如果迭代器为空，返回``False``。等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ascii">
<code class="descname">ascii</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#ascii" title="永久链接至目标">¶</a></dt>
<dd><p>就像函数 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>，返回一个对象可打印的字符串，但是 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串中非 ASCII 编码的字符，会使用 <code class="docutils literal notranslate"><span class="pre">\x</span></code>、<code class="docutils literal notranslate"><span class="pre">\u</span></code> 和 <code class="docutils literal notranslate"><span class="pre">\U</span></code> 来转义。生成的字符串和 Python 2 的 <a class="reference internal" href="#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的结果相似。</p>
</dd></dl>

<dl class="function">
<dt id="bin">
<code class="descname">bin</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#bin" title="永久链接至目标">¶</a></dt>
<dd><p>将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，那它需要定义 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>  方法返回一个整数。一些例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;0b11&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&#39;-0b1010&#39;</span>
</pre></div>
</div>
<p>如果不一定需要前缀“0b”，还可以使用如下的方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;#b&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:#b}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{14:b}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0b1110&#39;, &#39;1110&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
</dd></dl>

<dl class="class">
<dt id="bool">
<em class="property">class </em><code class="descname">bool</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个布尔值，<code class="docutils literal notranslate"><span class="pre">True</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 <em>x</em> 使用标准的 <a class="reference internal" href="stdtypes.html#truth"><span class="std std-ref">真值测试过程</span></a> 来转换。如果 <em>x</em> 是假的或者被省略，返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>；其他情况返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。<a class="reference internal" href="#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 类是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的子类（参见 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a>）。其他类不能继承自它。它只有 <code class="docutils literal notranslate"><span class="pre">False</span></code> 和 <code class="docutils literal notranslate"><span class="pre">True</span></code> 两个实例（参见 <a class="reference internal" href="stdtypes.html#bltin-boolean-values"><span class="std std-ref">布尔值</span></a>）。</p>
<div class="versionchanged" id="index-0">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="breakpoint">
<code class="descname">breakpoint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="headerlink" href="#breakpoint" title="永久链接至目标">¶</a></dt>
<dd><p>此函数会在调用时将你陷入调试器中。具体来说，它调用 <a class="reference internal" href="sys.html#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> ，直接传递 <code class="docutils literal notranslate"><span class="pre">args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">kws</span></code> 。默认情况下， <code class="docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code> 调用 <a class="reference internal" href="pdb.html#pdb.set_trace" title="pdb.set_trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.set_trace()</span></code></a> 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 <a class="reference internal" href="pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 且键入尽可能少的代码即可进入调试器。但是， <a class="reference internal" href="sys.html#sys.breakpointhook" title="sys.breakpointhook"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.breakpointhook()</span></code></a> 可以设置为其他一些函数并被 <a class="reference internal" href="#breakpoint" title="breakpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">breakpoint()</span></code></a> 自动调用，以允许进入你想用的调试器。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

<span class="target" id="func-bytearray"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytearray</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 bytes 数组。 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 <a class="reference internal" href="stdtypes.html#typesseq-mutable"><span class="std std-ref">可变序列类型</span></a> 的描述；同时有 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的大部分方法，参见 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul class="simple">
<li><p>如果是一个 <em>string</em>，您必须提供 <em>encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 会使用 <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 方法来将 string 转变成 bytes。</p></li>
<li><p>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</p></li>
<li><p>如果是一个符合 <em>buffer</em> 接口的对象，该对象的只读 buffer 会用来初始化字节数组。</p></li>
<li><p>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数，它会被用作数组的初始内容。</p></li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a> 和 <a class="reference internal" href="stdtypes.html#typebytearray"><span class="std std-ref">bytearray 对象</span></a>。</p>
</dd></dl>

<span class="target" id="func-bytes"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">bytes</code><span class="sig-paren">(</span><span class="optional">[</span><em>source</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> 的整数。<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 是 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 的不可变版本 - 它有其中不改变序列的方法和相同的索引、切片操作。</p>
<p>因此，构造函数的实参和 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 相同。</p>
<p>字节对象还可以用字面值创建，参见 <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">字符串和字节串字面值</span></a>。</p>
<p>另见 <a class="reference internal" href="stdtypes.html#binaryseq"><span class="std std-ref">二进制序列类型 --- bytes, bytearray, memoryview</span></a>，<a class="reference internal" href="stdtypes.html#typebytes"><span class="std std-ref">bytes 对象</span></a> 和 <a class="reference internal" href="stdtypes.html#bytes-methods"><span class="std std-ref">bytes 和 bytearray 操作</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#callable" title="永久链接至目标">¶</a></dt>
<dd><p>如果实参 <em>object</em> 是可调用的，返回 <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>，否则返回 <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。如果返回真，调用仍可能会失败；但如果返回假，则调用 <em>object</em> 肯定会失败。注意类是可调用的（调用类会返回一个新的实例）。如果实例的类有 <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> 方法，则它是可调用。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.2 新版功能: </span>这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="chr">
<code class="descname">chr</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#chr" title="永久链接至目标">¶</a></dt>
<dd><p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code class="docutils literal notranslate"><span class="pre">chr(97)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>，<code class="docutils literal notranslate"><span class="pre">chr(8364)</span></code> 返回字符串 <code class="docutils literal notranslate"><span class="pre">'€'</span></code>。这是 <a class="reference internal" href="#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="classmethod">
<code class="descclassname">&#64;</code><code class="descname">classmethod</code><a class="headerlink" href="#classmethod" title="永久链接至目标">¶</a></dt>
<dd><p>把一个方法封装成类方法。</p>
<p>一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>类方法的调用可以在类上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>) 也可以在实际上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅 <a class="reference internal" href="#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>。</p>
<p>想了解更多有关类方法的信息，请参阅 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> 。</p>
</dd></dl>

<dl class="function">
<dt id="compile">
<code class="descname">compile</code><span class="sig-paren">(</span><em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#compile" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 或 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。参见 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块的文档了解如何使用 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code class="docutils literal notranslate"><span class="pre">'&lt;string&gt;'</span></code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code>；如果是单一表达式，可以是 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code>；如果是单个交互式语句，可以是 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>。（在最后一种情况下，如果表达式执行结果不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制在编译 <em>source</em> 时要用到哪个 <a class="reference internal" href="../reference/simple_stmts.html#future"><span class="std std-ref">future 语句</span></a>。 如果两者都未提供（或都为零）则会使用调用 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 的代码中有效的 future 语句来编译代码。 如果给出了 <em>flags</em> 参数但没有 <em>dont_inherit</em> (或是为零) 则 <em>flags</em> 参数所指定的 以及那些无论如何都有效的 future 语句会被使用。 如果 <em>dont_inherit</em> 为一个非零整数，则只使用 <em>flags</em> 参数 -- 在调用外围有效的 future 语句将被忽略。</p>
<p>Future 语句使用比特位来指定，多个语句可以通过按位或来指定。具体特性的比特位可以通过 <a class="reference internal" href="__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>  模块中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">_Feature</span></code> 类的实例的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code> 属性来获得。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code class="docutils literal notranslate"><span class="pre">-1</span></code>  选择与解释器的 <a class="reference internal" href="../using/cmdline.html#cmdoption-o"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项相同的优化级别。显式级别为 <code class="docutils literal notranslate"><span class="pre">0</span></code> （没有优化；<code class="docutils literal notranslate"><span class="pre">__debug__</span></code>  为真）、<code class="docutils literal notranslate"><span class="pre">1</span></code> （断言被删除， <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 为假）或 <code class="docutils literal notranslate"><span class="pre">2</span></code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 异常；如果源码包含 null 字节，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
<p>如果您想分析 Python 代码的 AST 表示，请参阅 <a class="reference internal" href="ast.html#ast.parse" title="ast.parse"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.parse()</span></code></a>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">'single'</span></code>  或 <code class="docutils literal notranslate"><span class="pre">'eval'</span></code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a> 模块更容易检测语句的完整性。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可以因为 Python AST 编译器的栈深度限制而崩溃。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版更改: </span>允许使用 Windows 和 Mac 的换行符。在 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 模式不再需要以换行符结尾。增加了  <em>optimize</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>之前 <em>source</em> 中包含 null 字节的话会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="complex">
<em class="property">class </em><code class="descname">complex</code><span class="sig-paren">(</span><span class="optional">[</span><em>real</em><span class="optional">[</span>, <em>imag</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#complex" title="永久链接至目标">¶</a></dt>
<dd><p>返回值为 <em>real</em> + <em>imag</em>*1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 <em>imag</em>，则默认值为零，构造函数会像 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 和 <a class="reference internal" href="#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 一样进行数值转换。如果两个实参都省略，则返回 <code class="docutils literal notranslate"><span class="pre">0j</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>当从字符串转换时，字符串在 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> 的周围必须不能有空格。例如 <code class="docutils literal notranslate"><span class="pre">complex('1+2j')</span></code> 是合法的，但 <code class="docutils literal notranslate"><span class="pre">complex('1</span> <span class="pre">+</span> <span class="pre">2j')</span></code> 会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。</p>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了复数类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="delattr">
<code class="descname">delattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#delattr" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a> 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 <code class="docutils literal notranslate"><span class="pre">delattr(x,</span> <span class="pre">'foobar')</span></code>  等价于 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x.foobar</span></code> 。</p>
</dd></dl>

<span class="target" id="func-dict"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>mapping</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">dict</code><span class="sig-paren">(</span><em>iterable</em>, <em>**kwarg</em><span class="sig-paren">)</span></dt>
<dd><p>创建一个新的字典。<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 对象是一个字典类。参见 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和 <a class="reference internal" href="stdtypes.html#typesmapping"><span class="std std-ref">映射类型 --- dict</span></a> 了解这个类。</p>
<p>其他容器类型，请参见内置的 <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="function">
<dt id="dir">
<code class="descname">dir</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dir" title="永久链接至目标">¶</a></dt>
<dd><p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 函数的对象能够自定义 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 来报告它们的属性。</p>
<p>如果对象不提供 <a class="reference internal" href="../reference/datamodel.html#object.__dir__" title="object.__dir__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code></a>，这个函数会尝试从对象已定义的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性和类型对象收集信息。结果列表并不总是完整的，如果对象有自定义 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>，那结果可能不准确。</p>
<p>默认的 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul class="simple">
<li><p>如果对象是模块对象，则列表包含模块的属性名称。</p></li>
<li><p>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</p></li>
<li><p>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</p></li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>   <span class="c1"># show the names in the module namespace  # doctest: +SKIP</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;struct&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>   <span class="c1"># show the names in the struct module # doctest: +SKIP</span>
<span class="go">[&#39;Struct&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;,</span>
<span class="go"> &#39;__initializing__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;,</span>
<span class="go"> &#39;_clearcache&#39;, &#39;calcsize&#39;, &#39;error&#39;, &#39;pack&#39;, &#39;pack_into&#39;,</span>
<span class="go"> &#39;unpack&#39;, &#39;unpack_from&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;area&#39;, &#39;location&#39;, &#39;perimeter&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>因为 <a class="reference internal" href="#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#divmod" title="永久链接至目标">¶</a></dt>
<dd><p>它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> 一致。对于浮点数，结果是 <code class="docutils literal notranslate"><span class="pre">(q,</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b)</span></code> ，<em>q</em> 通常是 <code class="docutils literal notranslate"><span class="pre">math.floor(a</span> <span class="pre">/</span> <span class="pre">b)</span></code> 但可能会比 1 小。在任何情况下， <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 和  <em>a</em> 基本相等；如果 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> 非零，它的符号和 <em>b</em> 一样，并且 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">abs(a</span> <span class="pre">%</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">abs(b)</span></code> 。</p>
</dd></dl>

<dl class="function">
<dt id="enumerate">
<code class="descname">enumerate</code><span class="sig-paren">(</span><em>iterable</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#enumerate" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>，或其他支持迭代的对象。 <a class="reference internal" href="#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 返回的迭代器的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seasons</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Spring&#39;</span><span class="p">,</span> <span class="s1">&#39;Summer&#39;</span><span class="p">,</span> <span class="s1">&#39;Fall&#39;</span><span class="p">,</span> <span class="s1">&#39;Winter&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">))</span>
<span class="go">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">seasons</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span>
</pre></div>
</div>
<p>等价于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span><span class="p">,</span> <span class="n">elem</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>expression</em>, <em>globals=None</em>, <em>locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#eval" title="永久链接至目标">¶</a></dt>
<dd><p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p><em>expression</em> 参数会作为一个 Python 表达式（从技术上说是一个条件列表）被解析并求值，使用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果 <em>globals</em> 字典存在且不包含以 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 为键的值，则会在解析 <em>expression</em> 之前插入以此为键的对内置模块 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 的字典的引用。 这意味着 <em>expression</em> 通常具有对标准 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块的完全访问权限且受限的环境会被传播。 如果省略 <em>locals</em> 字典则其默认值为 <em>globals</em> 字典。 如果两个字典同时省略，表达式会在 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 被调用的环境中执行。 返回值为表达式求值的结果。 语法错误将作为异常被报告。 例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x+1&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>这个函数也可以用来执行任何代码对象（如 <a class="reference internal" href="#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>  创建的）。这种情况下，参数是代码对象，而不是字符串。如果编译该对象时的 <em>mode</em> 实参是 <code class="docutils literal notranslate"><span class="pre">'exec'</span></code> 那么 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 返回值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>提示： <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数支持动态执行语句。 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此您可以将它们传递给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 或 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 来使用。</p>
<p>另外可以参阅 <a class="reference internal" href="ast.html#ast.literal_eval" title="ast.literal_eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">ast.literal_eval()</span></code></a>，该函数可以安全执行仅包含文字的表达式字符串。</p>
</dd></dl>

<span class="target" id="index-1"></span><dl class="function">
<dt id="exec">
<code class="descname">exec</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>globals</em><span class="optional">[</span>, <em>locals</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#exec" title="永久链接至目标">¶</a></dt>
<dd><p>这个函数支持动态执行 Python 代码。<em>object</em> 必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。<a class="footnote-reference brackets" href="#id2" id="id1">1</a> 如果是代码对象，它将被直接执行。在任何情况下，被执行的代码都需要和文件输入一样是有效的（见参考手册中关于文件输入的章节）。请注意即使在传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数的代码的上下文中，<a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 和 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句也不能在函数定义之外使用。该函数返回值是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>无论哪种情况，如果省略了可选参数，代码将在当前范围内执行。如果提供了 <em>globals</em> 参数，就必须是字典类型，而且会被用作全局和本地变量。如果同时提供了 <em>globals</em> 和 <em>locals</em> 参数，它们分别被用作全局和本地变量。如果提供了 <em>locals</em> 参数，则它可以是任何映射型的对象。请记住在模块层级，全局和本地变量是相同的字典。如果 exec 有两个不同的 <em>globals</em> 和 <em>locals</em> 对象，代码就像嵌入在类定义中一样执行。</p>
<p>如果 <em>globals</em> 字典不包含 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 键值，则将为该键插入对内建 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块字典的引用。因此，在将执行的代码传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 之前，可以通过将自己的 <code class="docutils literal notranslate"><span class="pre">__builtins__</span></code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>内置 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 和 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 的第二个和第三个实参。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>默认情况下，<em>locals</em> 的行为如下面 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。如果您想在 <a class="reference internal" href="#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 函数返回时知道代码对 <em>locals</em> 的变动，请明确地传递 <em>locals</em> 字典。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#filter" title="永久链接至目标">¶</a></dt>
<dd><p>用 <em>iterable</em>  中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code class="docutils literal notranslate"><span class="pre">filter(function,</span> <span class="pre">iterable)</span></code> 相当于一个生成器表达式，当 function 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">function(item))</span></code>；function 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候为 <code class="docutils literal notranslate"><span class="pre">(item</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">iterable</span> <span class="pre">if</span> <span class="pre">item)</span></code> 。</p>
<p>请参阅 <a class="reference internal" href="itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.filterfalse()</span></code></a> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
</dd></dl>

<dl class="class">
<dt id="float">
<em class="property">class </em><code class="descname">float</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#float" title="永久链接至目标">¶</a></dt>
<dd><p id="index-2">返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> ； <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 对创建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。确切地说，除去首尾的空格后，输入必须遵循以下语法：</p>
<pre>
<strong id="grammar-token-sign">sign          </strong> ::=  &quot;+&quot; | &quot;-&quot;
<strong id="grammar-token-infinity">infinity      </strong> ::=  &quot;Infinity&quot; | &quot;inf&quot;
<strong id="grammar-token-nan">nan           </strong> ::=  &quot;nan&quot;
<strong id="grammar-token-numeric-value">numeric_value </strong> ::=  <a class="reference internal" href="../reference/lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="#grammar-token-infinity"><code class="xref docutils literal notranslate"><span class="pre">infinity</span></code></a> | <a class="reference internal" href="#grammar-token-nan"><code class="xref docutils literal notranslate"><span class="pre">nan</span></code></a>
<strong id="grammar-token-numeric-string">numeric_string</strong> ::=  [<a class="reference internal" href="#grammar-token-sign"><code class="xref docutils literal notranslate"><span class="pre">sign</span></code></a>] <a class="reference internal" href="#grammar-token-numeric-value"><code class="xref docutils literal notranslate"><span class="pre">numeric_value</span></code></a>
</pre>
<p>这里， <code class="docutils literal notranslate"><span class="pre">floatnumber</span></code> 是 Python 浮点数的字符串形式，详见 <a class="reference internal" href="../reference/lexical_analysis.html#floating"><span class="std std-ref">浮点数字面值</span></a>。字母大小写都可以，例如，“inf”、“Inf”、“INFINITY”、“iNfINity” 都可以表示正无穷大。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p>
<p>对于一般的 Python 对象 <code class="docutils literal notranslate"><span class="pre">x</span></code> ， <code class="docutils literal notranslate"><span class="pre">float(x)</span></code> 指派给 <code class="docutils literal notranslate"><span class="pre">x.__float__()</span></code> 。</p>
<p>如果没有实参，则返回 <code class="docutils literal notranslate"><span class="pre">0.0</span></code> 。</p>
<p>例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1.23&#39;</span><span class="p">)</span>
<span class="go">1.23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;   -12345</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">-12345.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;1e-003&#39;</span><span class="p">)</span>
<span class="go">0.001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+1E6&#39;</span><span class="p">)</span>
<span class="go">1000000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 描述了浮点类型。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
</dd></dl>

<span class="target" id="index-3"></span><dl class="function">
<dt id="format">
<code class="descname">format</code><span class="sig-paren">(</span><em>value</em><span class="optional">[</span>, <em>format_spec</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#format" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>value</em> 转换为 <em>format_spec</em> 控制的“格式化”表示。<em>format_spec</em> 的解释取决于 <em>value</em> 实参的类型，但是大多数内置类型使用标准格式化语法：<a class="reference internal" href="string.html#formatspec"><span class="std std-ref">格式规格迷你语言</span></a>。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常和调用 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(value)</span></code></a> 的结果相同。</p>
<p>调用 <code class="docutils literal notranslate"><span class="pre">format(value,</span> <span class="pre">format_spec)</span></code> 会转换成  <code class="docutils literal notranslate"><span class="pre">type(value).__format__(value,</span> <span class="pre">format_spec)</span></code> ，所以实例字典中的 <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法将不会调用。如果搜索到 <a class="reference internal" href="#object" title="object"><code class="xref py py-mod docutils literal notranslate"><span class="pre">object</span></code></a> 有这个方法但  <em>format_spec</em> 不为空，<em>format_spec</em> 或返回值不是字符串，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当 <em>format_spec</em> 不是空字符串时， <code class="docutils literal notranslate"><span class="pre">object().__format__(format_spec)</span></code> 会触发  <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<span class="target" id="func-frozenset"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code class="docutils literal notranslate"><span class="pre">frozenset</span></code> 是一个内置的类。有关此类的文档，请参阅 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 和 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a>。</p>
<p>请参阅内建的 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>、<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>、<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块来了解其它的容器。</p>
</dd></dl>

<dl class="function">
<dt id="getattr">
<code class="descname">getattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#getattr" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象命名属性的值。<em>name</em> 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， <code class="docutils literal notranslate"><span class="pre">getattr(x,</span> <span class="pre">'foobar')</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span></code>。如果指定的属性不存在，且提供了 <em>default</em> 值，则返回它，否则触发 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
</dd></dl>

<dl class="function">
<dt id="globals">
<code class="descname">globals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#globals" title="永久链接至目标">¶</a></dt>
<dd><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p>
</dd></dl>

<dl class="function">
<dt id="hasattr">
<code class="descname">hasattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#hasattr" title="永久链接至目标">¶</a></dt>
<dd><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。（此功能是通过调用 <code class="docutils literal notranslate"><span class="pre">getattr(object,</span> <span class="pre">name)</span></code> 看是否有 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 异常来实现的。）</p>
</dd></dl>

<dl class="function">
<dt id="hash">
<code class="descname">hash</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#hash" title="永久链接至目标">¶</a></dt>
<dd><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果对象实现了自己的 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 方法，请注意，<a class="reference internal" href="#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 根据机器的字长来截断返回值。另请参阅 <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="help">
<code class="descname">help</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#help" title="永久链接至目标">¶</a></dt>
<dd><p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意如果在函数的形参列表中出现了斜杠 (/)，则它在发起调用 <a class="reference internal" href="#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 的时候意味着斜杠之前的均为仅限位置形参。 更多相关信息，请参阅 <a class="reference internal" href="../faq/programming.html#faq-positional-only-arguments"><span class="std std-ref">有关仅限位置形参的 FAQ 条目</span></a>。</p>
<p>该函数通过 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块加入到内置命名空间。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span><a class="reference internal" href="pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 和 <a class="reference internal" href="inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 的变更使得可调用对象的签名信息更加全面和一致。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="hex">
<code class="descname">hex</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#hex" title="永久链接至目标">¶</a></dt>
<dd><p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，则必须定义返回整数的 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 方法。一些例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="go">&#39;0xff&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="o">-</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;-0x2a&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%X</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">255</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;#x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:#x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:x}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{255:X}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0xff&#39;, &#39;ff&#39;, &#39;FF&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<p>另请参阅 <a class="reference internal" href="#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 将十六进制字符串转换为以 16 为基数的整数。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <a class="reference internal" href="stdtypes.html#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> 方法。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="id">
<code class="descname">id</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#id" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <a class="reference internal" href="#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 值。</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> This is the address of the object in memory.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="input">
<code class="descname">input</code><span class="sig-paren">(</span><span class="optional">[</span><em>prompt</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#input" title="永久链接至目标">¶</a></dt>
<dd><p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>。例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;--&gt; &#39;</span><span class="p">)</span>  
<span class="go">--&gt; Monty Python&#39;s Flying Circus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>  
<span class="go">&quot;Monty Python&#39;s Flying Circus&quot;</span>
</pre></div>
</div>
<p>如果加载了 <a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块，<a class="reference internal" href="#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 将使用它来提供复杂的行编辑和历史记录功能。</p>
</dd></dl>

<dl class="class">
<dt id="int">
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><span class="optional">[</span><em>x</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#int" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">int</code><span class="sig-paren">(</span><em>x</em>, <em>base=10</em><span class="sig-paren">)</span></dt>
<dd><p>返回一个使用数字或字符串 <em>x</em> 生成的整数对象，或者没有实参的时候返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 。如果 <em>x</em> 定义了 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>，<code class="docutils literal notranslate"><span class="pre">int(x)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">x.__int__()</span></code> 。如果 <em>x</em> 定义了 <a class="reference internal" href="../reference/datamodel.html#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a>，它返回 <code class="docutils literal notranslate"><span class="pre">x.__trunc__()</span></code> 。对于浮点数，它向零舍入。</p>
<p>如果 <em>x</em> 不是数字，或者有 <em>base</em> 参数，<em>x</em> 必须是字符串、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、表示进制为 <em>base</em> 的 <a class="reference internal" href="../reference/lexical_analysis.html#integers"><span class="std std-ref">整数字面值</span></a> 的 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 实例。该文字前可以有 <code class="docutils literal notranslate"><span class="pre">+</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-</span></code> （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 <code class="docutils literal notranslate"><span class="pre">a</span></code> 到 <code class="docutils literal notranslate"><span class="pre">z</span></code> （或 <code class="docutils literal notranslate"><span class="pre">A</span></code> 到 <code class="docutils literal notranslate"><span class="pre">Z</span></code> ）表示 10 到 35。默认的 <em>base</em> 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 <code class="docutils literal notranslate"><span class="pre">0b</span></code>/<code class="docutils literal notranslate"><span class="pre">0B</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0o</span></code>/<code class="docutils literal notranslate"><span class="pre">0O</span></code> 、 <code class="docutils literal notranslate"><span class="pre">0x</span></code>/<code class="docutils literal notranslate"><span class="pre">0X</span></code> 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">0)</span></code> 是非法的，但 <code class="docutils literal notranslate"><span class="pre">int('010')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int('010',</span> <span class="pre">8)</span></code> 是合法的。</p>
<p>整数类型定义请参阅 <a class="reference internal" href="stdtypes.html#typesnumeric"><span class="std std-ref">数字类型 --- int, float, complex</span></a> 。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果 <em>base</em> 不是 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 的实例，但 <em>base</em> 对象有 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a> 方法，则会调用该方法来获取进制数。以前的版本使用 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__int__</span></code></a> 而不是 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base.__index__</span></code></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>您可以使用下划线将代码文字中的数字进行分组。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><em>x</em> 现在只能作为位置参数。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="isinstance">
<code class="descname">isinstance</code><span class="sig-paren">(</span><em>object</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#isinstance" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>object</em> 实参是 <em>classinfo</em> 实参的实例，或者是（直接、间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a>）子类的实例，则返回 true。如果 <em>object</em> 不是给定类型的对象，函数始终返回 false。如果 <em>classinfo</em> 是对象类型（或多个递归元组）的元组，如果 <em>object</em> 是其中的任何一个的实例则返回 true。 如果 <em>classinfo</em> 既不是类型，也不是类型元组或类型的递归元组，那么会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="issubclass">
<code class="descname">issubclass</code><span class="sig-paren">(</span><em>class</em>, <em>classinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#issubclass" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>class</em> 是 <em>classinfo</em> 的子类（直接、间接或 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">虚拟</span></a> 的），则返回 true。<em>classinfo</em> 可以是类对象的元组，此时 <em>classinfo</em> 中的每个元素都会被检查。其他情况，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p>
</dd></dl>

<dl class="function">
<dt id="iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>sentinel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#iter" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持迭代协议（有 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 方法）的集合对象，或必须支持序列协议（有 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法，且数字参数从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 开始）。如果它不支持这些协议，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。如果有第二个实参 <em>sentinel</em>，那么 <em>object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法时都会不带实参地调用 <em>object</em>；如果返回的结果是 <em>sentinel</em> 则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>，否则返回调用结果。</p>
<p>另请参阅 <a class="reference internal" href="stdtypes.html#typeiter"><span class="std std-ref">迭代器类型</span></a>。</p>
<p>适合 <a class="reference internal" href="#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mydata.db&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">process_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="len">
<code class="descname">len</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="永久链接至目标">¶</a></dt>
<dd><p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
</dd></dl>

<span class="target" id="func-list"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">list</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>除了是函数，<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 也是可变序列类型，详情请参阅 <a class="reference internal" href="stdtypes.html#typesseq-list"><span class="std std-ref">列表</span></a> 和 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="locals">
<code class="descname">locals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#locals" title="永久链接至目标">¶</a></dt>
<dd><p>更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 时将返回自由变量。 请注意在模块层级上，<a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 和 <a class="reference internal" href="#globals" title="globals"><code class="xref py py-func docutils literal notranslate"><span class="pre">globals()</span></code></a> 是同一个字典。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="map">
<code class="descname">map</code><span class="sig-paren">(</span><em>function</em>, <em>iterable</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#map" title="永久链接至目标">¶</a></dt>
<dd><p>产生一个将 <em>function</em> 应用于迭代器中所有元素并返回结果的迭代器。如果传递了额外的 <em>iterable</em> 实参，<em>function</em> 必须接受相同个数的实参，并使用所有迭代器中并行获取的元素。当有多个迭代器时，最短的迭代器耗尽则整个迭代结束。如果函数的输入已经是元组实参，请参阅 <a class="reference internal" href="itertools.html#itertools.starmap" title="itertools.starmap"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.starmap()</span></code></a>。</p>
</dd></dl>

<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#max" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">max</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc,</span> <span class="pre">reverse=True)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nlargest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
</dd></dl>

<span class="target" id="func-memoryview"></span><dl class="function">
<dt>
<code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span></dt>
<dd><p>返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.html#typememoryview"><span class="std std-ref">内存视图</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="min">
<code class="descname">min</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em><span class="optional">[</span>, <em>key</em>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#min" title="永久链接至目标">¶</a></dt>
<dt>
<code class="descname">min</code><span class="sig-paren">(</span><em>arg1</em>, <em>arg2</em>, <em>*args</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a class="reference internal" href="stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code class="docutils literal notranslate"><span class="pre">sorted(iterable,</span> <span class="pre">key=keyfunc)[0]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heapq.nsmallest(1,</span> <span class="pre">iterable,</span> <span class="pre">key=keyfunc)</span></code> 保持一致。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能: </span>keyword-only 实参 <em>default</em> 。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="next">
<code class="descname">next</code><span class="sig-paren">(</span><em>iterator</em><span class="optional">[</span>, <em>default</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#next" title="永久链接至目标">¶</a></dt>
<dd><p>通过调用 <em>iterator</em> 的 <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。</p>
</dd></dl>

<dl class="class">
<dt id="object">
<em class="property">class </em><code class="descname">object</code><a class="headerlink" href="#object" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个没有特征的新对象。<a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>由于 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 没有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>，因此无法将任意属性赋给 <a class="reference internal" href="#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的实例。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="oct">
<code class="descname">oct</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#oct" title="永久链接至目标">¶</a></dt>
<dd><p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 对象，那它需要定义 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>  方法返回一个整数。一些例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;0o10&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="o">-</span><span class="mi">56</span><span class="p">)</span>
<span class="go">&#39;-0o70&#39;</span>
</pre></div>
</div>
<p>如果要将整数转换为八进制字符串，并可选择有无“0o”前缀，则可以使用如下方法：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%#o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%o</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;#o&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:#o}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{10:o}</span><span class="s1">&#39;</span>
<span class="go">(&#39;0o12&#39;, &#39;12&#39;)</span>
</pre></div>
</div>
<p>另见 <a class="reference internal" href="#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 获取更多信息。</p>
<blockquote>
<div><span class="target" id="index-4"></span></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file</em>, <em>mode='r'</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em><span class="sig-paren">)</span><a class="headerlink" href="#open" title="永久链接至目标">¶</a></dt>
<dd><p>打开 <em>file</em> 并返回对应的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>。如果该文件不能打开，则触发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<p><em>file</em> 是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 <em>closefd</em> 被设为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 。）</p>
<p><em>mode</em> 是一个可选字符串，用于指定打开文件的模式。默认值是 <code class="docutils literal notranslate"><span class="pre">'r'</span></code>  ，这意味着它以文本模式打开并读取。其他常见模式有：写入 <code class="docutils literal notranslate"><span class="pre">'w'</span></code> （截断已经存在的文件）；排它性创建 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ；追加写 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> （在 <em>一些</em>  Unix 系统上，无论当前的文件指针在什么位置，<em>所有</em> 写入都会追加到文件末尾）。在文本模式，如果 <em>encoding</em> 没有指定，则根据平台来决定使用的编码：使用 <code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding(False)</span></code> 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 <em>encoding</em>。）可用的模式有：</p>
<span class="target" id="filemodes"></span><table class="docutils align-center" id="index-5">
<colgroup>
<col style="width: 13%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>字符</p></th>
<th class="head"><p>意义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
<td><p>读取（默认）</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'w'</span></code></p></td>
<td><p>写入，并先截断文件</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code></p></td>
<td><p>排它性创建，如果文件已存在则失败</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
<td><p>写入，如果文件存在则在末尾追加</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p>二进制模式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'t'</span></code></p></td>
<td><p>文本模式（默认）</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'+'</span></code></p></td>
<td><p>更新磁盘文件（读取并写入）</p></td>
</tr>
</tbody>
</table>
<p>默认的模式是 <code class="docutils literal notranslate"><span class="pre">'r'</span></code> （打开并读取文本，同 <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> ）。对于二进制写入， <code class="docutils literal notranslate"><span class="pre">'w+b'</span></code> 模式打开并把文件截断成 0 字节； <code class="docutils literal notranslate"><span class="pre">'r+b'</span></code> 则不会截断。</p>
<p>正如在 <a class="reference internal" href="io.html#io-overview"><span class="std std-ref">概述</span></a> 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code class="docutils literal notranslate"><span class="pre">'b'</span></code> ）返回的内容为 <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes`对象，不进行任何解码。在文本模式下（默认情况下，或者在</span> <span class="pre">*mode*</span> <span class="pre">参数中包含</span> <span class="pre">`</span></code>'t'` ）时，文件内容返回为 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<p>此外还允许使用一个模式字符 <code class="docutils literal notranslate"><span class="pre">'U'</span></code>，该字符已不再具有任何效果，并被视为已弃用。 之前它会在文本模式中启用 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>，这在 Python 3.0 中成为默认行为。 请参阅 <a class="reference internal" href="#open-newline-parameter"><span class="std std-ref">newline</span></a> 形参的文档了解更多细节。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
</div>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且&gt;1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出 <em>buffering</em> 参数，则默认缓冲策略的工作方式如下:</p>
<ul class="simple">
<li><p>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 <a class="reference internal" href="io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.DEFAULT_BUFFER_SIZE</span></code></a>。在许多系统上，缓冲区的长度通常为4096或8192字节。</p></li>
<li><p>“交互式”文本文件（ <a class="reference internal" href="io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isatty()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</p></li>
</ul>
<p><em>encoding</em> 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 <a class="reference internal" href="locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getpreferredencoding()</span></code></a> 返回何值），但可以使用任何Python支持的 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> 。有关支持的编码列表，请参阅 <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块。</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Error Handlers</span></a> ），但是使用 <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul class="simple">
<li><p>如果存在编码错误，<code class="docutils literal notranslate"><span class="pre">'strict'</span></code> 会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。 默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code> 具有相同的效果。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 会将替换标记（例如 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> ）插入有错误数据的地方。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> 将表示任何不正确的字节作为Unicode专用区中的代码点，范围从U+DC80到U+DCFF。当在写入数据时使用 <code class="docutils literal notranslate"><span class="pre">surrogateescape</span></code> 错误处理程序时，这些私有代码点将被转回到相同的字节中。这对于处理未知编码的文件很有用。</p></li>
<li><p>只有在写入文件时才支持 <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code>。编码不支持的字符将替换为相应的XML字符引用 <code class="docutils literal notranslate"><span class="pre">&amp;#nnn;</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> 用Python的反向转义序列替换格式错误的数据。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> （也只在编写时支持）用 <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code> 转义序列替换不支持的字符。</p></li>
</ul>
<p id="open-newline-parameter"><span id="index-6"></span><em>newline</em> 控制 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 模式如何生效（它仅适用于文本模式）。它可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，<code class="docutils literal notranslate"><span class="pre">''</span></code>，<code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，<code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>。它的工作原理:</p>
<ul class="simple">
<li><p>从流中读取输入时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则启用通用换行模式。输入中的行可以以 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，<code class="docutils literal notranslate"><span class="pre">'\r'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code> 结尾，这些行被翻译成 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 在返回呼叫者之前。如果它是 <code class="docutils literal notranslate"><span class="pre">''</span></code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</p></li>
<li><p>将输出写入流时，如果 <em>newline</em> 为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符都将转换为系统默认行分隔符 <a class="reference internal" href="os.html#os.linesep" title="os.linesep"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.linesep</span></code></a>。如果 <em>newline</em> 是 <code class="docutils literal notranslate"><span class="pre">''</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符将被转换为给定的字符串。</p></li>
</ul>
<p>如果 <em>closefd</em> 是 <code class="docutils literal notranslate"><span class="pre">False</span></code> 并且给出了文件描述符而不是文件名，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出文件名则 <em>closefd</em> 必须为 <code class="docutils literal notranslate"><span class="pre">True</span></code> （默认值），否则将引发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file</em>，<em>flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.open</span></code></a> as <em>opener</em> 时与传递 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的效果相同）。</p>
<p>新创建的文件是 <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">不可继承的</span></a>。</p>
<p>下面的示例使用 <a class="reference internal" href="os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 函数的 <a class="reference internal" href="os.html#dir-fd"><span class="std std-ref">dir_fd</span></a> 的形参，从给定的目录中用相对路径打开文件:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dir_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;somedir&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">opener</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dir_fd</span><span class="o">=</span><span class="n">dir_fd</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;spamspam.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">opener</span><span class="o">=</span><span class="n">opener</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This will be written to somedir/spamspam.txt&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">dir_fd</span><span class="p">)</span>  <span class="c1"># don&#39;t leak a file descriptor</span>
</pre></div>
</div>
<p><a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函数所返回的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> 类型取决于所用模式。 当使用 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 以文本模式 (<code class="docutils literal notranslate"><span class="pre">'w'</span></code>, <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wt'</span></code>, <code class="docutils literal notranslate"><span class="pre">'rt'</span></code> 等) 打开文件时，它将返回 <a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> (特别是 <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a>；在写入二进制和追加二进制模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedWriter</span></code></a>，而在读/写模式下，它将返回 <a class="reference internal" href="io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedRandom</span></code></a>。 当禁用缓冲时，则会返回原始流，即 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的一个子类 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p>
<p id="index-7">另请参阅文件操作模块，例如 <a class="reference internal" href="fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a>、<a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> （声明了 <a class="reference internal" href="#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>）、<a class="reference internal" href="os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>、<a class="reference internal" href="os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a>、<a class="reference internal" href="tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a> 和 <a class="reference internal" href="shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a>。</p>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified changed">在 3.3 版更改: </span><ul class="simple">
<li><p>增加了 <em>opener</em> 形参。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'x'</span></code> 模式。</p></li>
<li><p>过去触发的 <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>，现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p></li>
<li><p>如果文件已存在但使用了排它性创建模式（ <code class="docutils literal notranslate"><span class="pre">'x'</span></code> ），现在会触发 <a class="reference internal" href="exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。</p></li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified changed">在 3.4 版更改: </span><ul class="simple">
<li><p>文件现在禁止继承。</p></li>
</ul>
</div></blockquote>
</div>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 3.4, will be removed in version 4.0: </span><code class="docutils literal notranslate"><span class="pre">'U'</span></code> 模式。</p>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified changed">在 3.5 版更改: </span><ul class="simple">
<li><p>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> 异常（原因详见 <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>）。</p></li>
<li><p>增加了 <code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code> 错误处理接口。</p></li>
</ul>
</div></blockquote>
</div>
<div class="versionchanged">
<blockquote>
<div><span class="versionmodified changed">在 3.6 版更改: </span><ul class="simple">
<li><p>增加对实现了 <a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> 对象的支持。</p></li>
<li><p>在 Windows 上，打开一个控制台缓冲区将返回 <a class="reference internal" href="io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.RawIOBase</span></code></a> 的子类，而不是 <a class="reference internal" href="io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>。</p></li>
</ul>
</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="ord">
<code class="descname">ord</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#ord" title="永久链接至目标">¶</a></dt>
<dd><p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code class="docutils literal notranslate"><span class="pre">ord('a')</span></code> 返回整数 <code class="docutils literal notranslate"><span class="pre">97</span></code>， <code class="docutils literal notranslate"><span class="pre">ord('€')</span></code> （欧元符合）返回 <code class="docutils literal notranslate"><span class="pre">8364</span></code> 。这是 <a class="reference internal" href="#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 的逆函数。</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<code class="descname">pow</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="optional">[</span>, <em>z</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pow" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>x</em> 的 <em>y</em> 次幂；如果 <em>z</em> 存在，则对 <em>z</em> 取余（比直接 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">z</span></code> 计算更高效）。两个参数形式的 <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code> 等价于幂运算符： <code class="docutils literal notranslate"><span class="pre">x**y</span></code>。</p>
<p>参数必须为数值类型。 对于混用的操作数类型，则适用二元算术运算符的类型强制转换规则。 对于 <a class="reference internal" href="#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 操作数，结果具有与操作数相同的类型（转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。 例如，<code class="docutils literal notranslate"><span class="pre">10**2</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">100</span></code>，但 <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0.01</span></code>。 如果第二个参数为负值，则第三个参数必须省略。 如果存在 <em>z</em>，则 <em>x</em> 和 <em>y</em> 必须为整数类型，且 <em>y</em> 必须为非负数。</p>
</dd></dl>

<dl class="function">
<dt id="print">
<code class="descname">print</code><span class="sig-paren">(</span><em>*objects</em>, <em>sep=' '</em>, <em>end='\n'</em>, <em>file=sys.stdout</em>, <em>flush=False</em><span class="sig-paren">)</span><a class="headerlink" href="#print" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>objects</em> 打印到 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 <em>end</em>。 <em>sep</em>, <em>end</em>, <em>file</em> 和 <em>flush</em> 如果存在，它们必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 一样，并会被写入到流，以 <em>sep</em> 且在末尾加上 <em>end</em>。 <em>sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，这意味着使用默认值。 如果没有给出 <em>objects</em>，则 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 将只写入 <em>end</em>。</p>
<p><em>file</em> 参数必须是一个具有 <code class="docutils literal notranslate"><span class="pre">write(string)</span></code> 方法的对象；如果参数不存在或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则将使用 <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>。 由于要打印的参数会被转换为文本字符串，因此 <a class="reference internal" href="#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code class="docutils literal notranslate"><span class="pre">file.write(...)</span></code>。</p>
<p>输出是否被缓存通常决定于 <em>file</em>，但如果 <em>flush</em> 关键字参数为真值，流会被强制刷新。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>flush</em> 关键字参数。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="property">
<em class="property">class </em><code class="descname">property</code><span class="sig-paren">(</span><em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#property" title="永久链接至目标">¶</a></dt>
<dd><p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s2">&quot;I&#39;m the &#39;x&#39; property.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <em>c</em> 是 <em>C</em> 的实例，<code class="docutils literal notranslate"><span class="pre">c.x</span></code> 将调用getter，<code class="docutils literal notranslate"><span class="pre">c.x</span> <span class="pre">=</span> <span class="pre">value</span></code> 将调用setter， <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">c.x</span></code> 将调用deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <a class="reference internal" href="#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 作为 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> 来创建只读的特征属性可以很容易地实现:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Parrot</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span> <span class="o">=</span> <span class="mi">100000</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voltage</span>
</pre></div>
</div>
<p>以上 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 装饰器会将 <code class="xref py py-meth docutils literal notranslate"><span class="pre">voltage()</span></code> 方法转化为一个具有相同名称的只读属性的 &quot;getter&quot;，并将 <em>voltage</em> 的文档字符串设置为 &quot;Get the current voltage.&quot;</p>
<p>特征属性对象具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">getter</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">setter</span></code> 以及 <code class="xref py py-attr docutils literal notranslate"><span class="pre">deleter</span></code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。  这最好是用一个例子来解释:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code class="docutils literal notranslate"><span class="pre">x</span></code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code class="docutils literal notranslate"><span class="pre">fget</span></code>, <code class="docutils literal notranslate"><span class="pre">fset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fdel</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>特性属性对象的文档字符串现在是可写的。</p>
</div>
</dd></dl>

<span class="target" id="func-range"></span><dl class="function">
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span></dt>
<dt>
<code class="descname">range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.html#typesseq-range"><span class="std std-ref">range 对象</span></a> 与 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="function">
<dt id="repr">
<code class="descname">repr</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#repr" title="永久链接至目标">¶</a></dt>
<dd><p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 <a class="reference internal" href="#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 方法来控制此函数为它的实例所返回的内容。</p>
</dd></dl>

<dl class="function">
<dt id="reversed">
<code class="descname">reversed</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#reversed" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个反向的 <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>。 <em>seq</em> 必须是一个具有 <a class="reference internal" href="../reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 方法的对象或者是支持该序列协议（具有从``0`` 开始的整数类型参数的 <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 方法和 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法）。</p>
</dd></dl>

<dl class="function">
<dt id="round">
<code class="descname">round</code><span class="sig-paren">(</span><em>number</em><span class="optional">[</span>, <em>ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#round" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则返回最接近输入值的整数。</p>
<p>对于支持 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 的内置类型，值会被舍入到最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数的距离相等，则选择偶数 (因此，<code class="docutils literal notranslate"><span class="pre">round(0.5)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">round(-0.5)</span></code> 均为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 而 <code class="docutils literal notranslate"><span class="pre">round(1.5)</span></code> 为 <code class="docutils literal notranslate"><span class="pre">2</span></code>)。 任何整数值都可作为有效的 <em>ndigits</em> (正数、零或负数)。 如果 <em>ndigits</em> 被省略或为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 则返回值将为整数。 否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code class="docutils literal notranslate"><span class="pre">number</span></code>, <code class="docutils literal notranslate"><span class="pre">round</span></code> 将委托给 <code class="docutils literal notranslate"><span class="pre">number.__round__</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>对浮点数执行 <a class="reference internal" href="#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 的行为可能会令人惊讶：例如，<code class="docutils literal notranslate"><span class="pre">round(2.675,</span> <span class="pre">2)</span></code> 将给出 <code class="docutils literal notranslate"><span class="pre">2.67</span></code> 而不是期望的 <code class="docutils literal notranslate"><span class="pre">2.68</span></code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 <a class="reference internal" href="../tutorial/floatingpoint.html#tut-fp-issues"><span class="std std-ref">浮点算术：争议和限制</span></a> 了解更多信息。</p>
</div>
</dd></dl>

<span class="target" id="func-set"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>返回一个新的 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code class="docutils literal notranslate"><span class="pre">set</span></code> 是一个内置类型。 请查看 <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="stdtypes.html#types-set"><span class="std std-ref">集合类型 --- set, frozenset</span></a> 获取关于这个类的文档。</p>
<p>有关其他容器请参看内置的 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 和 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类，以及 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块。</p>
</dd></dl>

<dl class="function">
<dt id="setattr">
<code class="descname">setattr</code><span class="sig-paren">(</span><em>object</em>, <em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#setattr" title="永久链接至目标">¶</a></dt>
<dd><p>此函数与 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 两相对应。 其参数为一个对象、一个字符串和一个任意值。 字符串指定一个现有属性或者新增属性。 函数会将值赋给该属性，只要对象允许这种操作。 例如，<code class="docutils literal notranslate"><span class="pre">setattr(x,</span> <span class="pre">'foobar',</span> <span class="pre">123)</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">x.foobar</span> <span class="pre">=</span> <span class="pre">123</span></code>。</p>
</dd></dl>

<dl class="class">
<dt id="slice">
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#slice" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">slice</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p id="index-9">返回一个表示由 <code class="docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 所指定索引集的 <a class="reference internal" href="../glossary.html#term-slice"><span class="xref std std-term">slice</span></a> 对象。 其中 <em>start</em> 和 <em>step</em> 参数默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性 <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code>。 它们没有其他的显式功能；不过它们会被 NumPy 以及其他第三方扩展所使用。 切片对象也会在使用扩展索引语法时被生成。 例如: <code class="docutils literal notranslate"><span class="pre">a[start:stop:step]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a[start:stop,</span> <span class="pre">i]</span></code>。 请参阅 <a class="reference internal" href="itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 了解返回迭代器的一种替代版本。</p>
</dd></dl>

<dl class="function">
<dt id="sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>iterable</em>, <em>*</em>, <em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sorted" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>)。 默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <a class="reference internal" href="#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 --- 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>有关排序示例和简要排序教程，请参阅 <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">排序指南</span></a> 。</p>
</dd></dl>

<dl class="function">
<dt id="staticmethod">
<code class="descclassname">&#64;</code><code class="descname">staticmethod</code><a class="headerlink" href="#staticmethod" title="永久链接至目标">¶</a></dt>
<dd><p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code> 这样的形式称为函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> -- 详情参阅 <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">函数定义</span></a>。</p>
<p>静态方法的调用可以在类上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C.f()</span></code>) 也可以在实例上进行 (例如 <code class="docutils literal notranslate"><span class="pre">C().f()</span></code>)。</p>
<p>Python中的静态方法与Java或C ++中的静态方法类似。另请参阅 <a class="reference internal" href="#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> ，用于创建备用类构造函数的变体。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">builtin_open</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="nb">open</span><span class="p">)</span>
</pre></div>
</div>
<p>想了解更多有关静态方法的信息，请参阅 <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">标准类型层级结构</span></a> 。</p>
</dd></dl>

<span class="target" id="func-str"><span id="index-10"></span></span><dl class="class">
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=''</em><span class="sig-paren">)</span></dt>
<dt>
<em class="property">class </em><code class="descname">str</code><span class="sig-paren">(</span><em>object=b''</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span></dt>
<dd><p>返回一个 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 版本的 <em>object</em> 。有关详细信息，请参阅 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 。</p>
<p><code class="docutils literal notranslate"><span class="pre">str</span></code> 是内置字符串 <a class="reference internal" href="../glossary.html#term-class"><span class="xref std std-term">class</span></a> 。更多关于字符串的信息查看 <a class="reference internal" href="stdtypes.html#textseq"><span class="std std-ref">文本序列类型 --- str</span></a>。</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="永久链接至目标">¶</a></dt>
<dd><p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 中的项求和并返回总计值。 <em>start</em> 默认为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 <em>iterable</em> 的项通常为数字，开始值则不允许为字符串。</p>
<p>对某些用例来说，存在 <a class="reference internal" href="#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code class="docutils literal notranslate"><span class="pre">''.join(sequence)</span></code>。 要以扩展精度对浮点值求和，请参阅 <a class="reference internal" href="math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fsum()</span></code></a>。 要拼接一系列可迭代对象，请考虑使用 <a class="reference internal" href="itertools.html#itertools.chain" title="itertools.chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.chain()</span></code></a>。</p>
</dd></dl>

<dl class="function">
<dt id="super">
<code class="descname">super</code><span class="sig-paren">(</span><span class="optional">[</span><em>type</em><span class="optional">[</span>, <em>object-or-type</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#super" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 指定的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。 搜索顺序与 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 所使用的相同，只是 <em>type</em> 指定的类型本身会被跳过。</p>
<p><em>type</em> 的 <a class="reference internal" href="stdtypes.html#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a> 属性列出了 <a class="reference internal" href="#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 和 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 所使用的方法解析顺序。 该属性是动态的，可以在继承层级结构更新的时候任意改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code> 必须为真值。 如果第二个参数为一个类型，则 <code class="docutils literal notranslate"><span class="pre">issubclass(type2,</span> <span class="pre">type)</span></code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有，在静态编译语言或仅支持单继承的语言中是不存在的。 这使得实现“菱形图”成为可能，在这时会有多个基类实现相同的方法。 好的设计强制要求这种方法在每个情况下具有相同的调用签名（因为调用顺序是在运行时确定的，也因为该顺序要适应类层级结构的更改，还因为该顺序可能包含在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>    <span class="c1"># This does the same thing as:</span>
                               <span class="c1"># super(C, self).method(arg)</span>
</pre></div>
</div>
<p>请注意 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 <code class="docutils literal notranslate"><span class="pre">super().__getitem__(name)</span></code>。 它做到这一点是通过实现自己的 <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 在像 <code class="docutils literal notranslate"><span class="pre">super()[name]</span></code> 这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>还要注意的是，除了零个参数的形式以外，<a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 并不限于在方法内部傅和。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要为普通访问当前实例。</p>
<p>对于有关如何使用 <a class="reference internal" href="#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 来如何设计协作类的实用建议，请参阅 <a class="reference external" href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">使用 super() 的指南</a>。</p>
</dd></dl>

<span class="target" id="func-tuple"></span><dl class="function">
<dt>
<code class="descname">tuple</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>虽然被称为函数，但 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 实际上是一个不可变的序列类型，参见在 <a class="reference internal" href="stdtypes.html#typesseq-tuple"><span class="std std-ref">元组</span></a> 与 <a class="reference internal" href="stdtypes.html#typesseq"><span class="std std-ref">序列类型 --- list, tuple, range</span></a> 中的文档说明。</p>
</dd></dl>

<dl class="class">
<dt id="type">
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="永久链接至目标">¶</a></dt>
<dt>
<em class="property">class </em><code class="descname">type</code><span class="sig-paren">(</span><em>name</em>, <em>bases</em>, <em>dict</em><span class="sig-paren">)</span></dt>
<dd><p id="index-11">传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <a class="reference internal" href="stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__class__</span></code></a> 所返回的对象相同。</p>
<p>推荐使用 <a class="reference internal" href="#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句的一种动态形式。 <em>name</em> 字符串即类名并且会成为 <a class="reference internal" href="stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性；<em>bases</em> 元组列出基类并且会成为 <a class="reference internal" href="stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 属性；而 <em>dict</em> 字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性。 例如，下面两条语句会创建相同的 <a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 对象:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>另请参阅 <a class="reference internal" href="stdtypes.html#bltin-type-objects"><span class="std std-ref">类型对象</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span><a class="reference internal" href="#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 的子类如果未重载 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>，将不再能使用一个参数的形式来获取对象的类型。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="vars">
<code class="descname">vars</code><span class="sig-paren">(</span><span class="optional">[</span><em>object</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#vars" title="永久链接至目标">¶</a></dt>
<dd><p>返回模块、类、实例或任何其它具有 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性的对象的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性；但是，其它对象的 <a class="reference internal" href="stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 属性可能会设为限制写入（例如，类会使用 <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> 来防止直接更新字典）。</p>
<p>不带参数时，<a class="reference internal" href="#vars" title="vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">vars()</span></code></a> 的行为类似 <a class="reference internal" href="#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
</dd></dl>

<dl class="function">
<dt id="zip">
<code class="descname">zip</code><span class="sig-paren">(</span><em>*iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#zip" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个聚合了来自每个可迭代对象中的元素的迭代器。</p>
<p>返回一个元组的迭代器，其中的第 <em>i</em> 个元组包含来自每个参数序列或可迭代对象的第 <em>i</em> 个元素。 当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代。 当只有一个可迭代对象参数时，它将返回一个单元组的迭代器。 不带参数时，它将返回一个空迭代器。 相当于:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c1"># zip(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax By</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
    <span class="n">iterators</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">iterators</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterators</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>函数会保证可迭代对象按从左至右的顺序被求值。 使得可以通过 <code class="docutils literal notranslate"><span class="pre">zip(*[iter(s)]*n)</span></code> 这样的惯用形式将一系列数据聚类为长度为 n 的分组。 这将重复 <em>同样的</em> 迭代器 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次，以便每个输出的元组具有第 <code class="docutils literal notranslate"><span class="pre">n</span></code> 次调用该迭代器的结果。 它的作用效果就是将输入拆分为长度为 n 的数据块。</p>
<p>当你不用关心较长可迭代对象末尾不匹配的值时，则 <a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 只须使用长度不相等的输入即可。 如果那些值很重要，则应改用 <a class="reference internal" href="itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a>。</p>
<p><a class="reference internal" href="#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 与 <code class="docutils literal notranslate"><span class="pre">*</span></code> 运算符相结合可以用来拆解一个列表:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="__import__">
<code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#__import__" title="永久链接至目标">¶</a></dt>
<dd><div class="admonition note" id="index-12">
<p class="admonition-title">注解</p>
<p>与 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
</div>
<p>此函数会由 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句发起调用。 它可以被替换 (通过导入 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模块并赋值给 <code class="docutils literal notranslate"><span class="pre">builtins.__import__</span></code>) 以便修改 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 而应该用 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>。</p>
<p>该函数会导入 <em>name</em> 模块，有可能使用给定的 <em>globals</em> 和 <em>locals</em> 来确定如何在包的上下文中解读名称。 <em>fromlist</em> 给出了应该从由 <em>name</em> 指定的模块导入对象或子模块的名称。 标准实现完全不使用其 <em>locals</em> 参数，而仅使用 <em>globals</em> 参数来确定 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code class="docutils literal notranslate"><span class="pre">0</span></code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 的目录，将要搜索的父目录层数 (详情参见 <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>)。</p>
<p>当 <em>name</em> 变量的形式为 <code class="docutils literal notranslate"><span class="pre">package.module</span></code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam</span></code> 的结果将为与以下代码作用相同的字节码:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spam.ham</span></code> 的结果将为以下调用:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意在这里 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 是如何返回顶层模块的，因为这是通过 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">spam.ham</span> <span class="pre">import</span> <span class="pre">eggs,</span> <span class="pre">sausage</span> <span class="pre">as</span> <span class="pre">saus</span></code> 的结果将为</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">_temp</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;spam.ham&#39;</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eggs</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">eggs</span>
<span class="n">saus</span> <span class="o">=</span> <span class="n">_temp</span><span class="o">.</span><span class="n">sausage</span>
</pre></div>
</div>
<p>在这里， <code class="docutils literal notranslate"><span class="pre">spam.ham</span></code> 模块会由 <a class="reference internal" href="#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <a class="reference internal" href="importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>Negative values for <em>level</em> are no longer supported (which also changes
the default value to 0).</p>
</div>
</dd></dl>

<p class="rubric">脚注</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>解析器只接受 Unix 风格的行结束符。如果您从文件中读取代码，请确保用换行符转换模式转换 Windows 或 Mac 风格的换行符。</p>
</dd>
</dl>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>上一个主题</h4>
  <p class="topless"><a href="intro.html"
                        title="上一章">概述</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="constants.html"
                        title="下一章">内置常量</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.7/Doc/library/functions.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="constants.html" title="内置常量"
             >下一页</a> |</li>
        <li class="right" >
          <a href="intro.html" title="概述"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2019, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    最后更新于 5月 30, 2019.
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>2.0.1 创建。
    </div>

  </body>
</html>