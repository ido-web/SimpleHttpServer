
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>importlib --- import 的实现 &#8212; Python 3.7.3 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.7.3 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="Python 语言服务" href="language.html" />
    <link rel="prev" title="runpy --- Locating and executing Python modules" href="runpy.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/importlib.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
    
    
    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="language.html" title="Python 语言服务"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- Locating and executing Python modules"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">导入模块</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现<a class="headerlink" href="#module-importlib" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
<p><strong>源代码</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<div class="section" id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 包的目的有两个。 第一个目的是在 Python 源代码中提供 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的实现（并且因此而扩展 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数）。 这提供了一个可移植到任何 Python 解释器的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 实现。 相比使用 Python 以外的编程语言实现方式，这一实现更加易于理解。</p>
<p>第二个目的是实现 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 的部分被公开在这个包中，使得用户更容易创建他们自己的自定义对象 (通常被称为 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>) 来参与到导入过程中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">import 语句</span></a></dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的语言参考</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">包规格说明</a></dt><dd><p>包的初始规范。自从编写这个文档开始，一些语义已经发生改变了（比如基于 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的重定向）。</p>
</dd>
<dt><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数</dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句是这个函数的语法糖。</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt><dd><p>在忽略大小写的平台上进行导入</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt><dd><p>定义 Python 源代码编码</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt><dd><p>新导入钩子</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt><dd><p>导入：多行和绝对/相对</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt><dd><p>主模块显式相对导入</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></dt><dd><p>隐式命名空间包</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt><dd><p>导入系统的一个模块规范类型</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></dt><dd><p>消除PYO文件</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></dt><dd><p>多阶段扩展模块初始化</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0552"><strong>PEP 552</strong></a></dt><dd><p>确定性的 pyc 文件</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt><dd><p>使用 UTF-8 作为默认的源编码</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt><dd><p>PYC 仓库目录</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>函数<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt id="importlib.__import__">
<code class="descclassname">importlib.</code><code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="永久链接至目标">¶</a></dt>
<dd><p>内置 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数的实现。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>程序式地导入模块应该使用 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 而不是这个函数。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.import_module">
<code class="descclassname">importlib.</code><code class="descname">import_module</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="永久链接至目标">¶</a></dt>
<dd><p>导入一个模块。参数 <em>name</em> 指定了以绝对或相对导入方式导入什么模块 (比如要么像这样 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> 或者这样 <code class="docutils literal notranslate"><span class="pre">..mod</span></code>)。如果参数 name 使用相对导入的方式来指定，那么那个参数 <em>packages</em> 必须设置为那个包名，这个包名作为解析这个包名的锚点 (比如  <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> 将会导入 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)。</p>
<p><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 函数是一个对 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a> 进行简化的包装器。 这意味着该函数的所有主义都来自于 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>。 这两个函数之间最重要的不同点在于 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 返回指定的包或模块 (例如 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)，而 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 返回最高层级的包或模块 (例如 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>)。</p>
<p>如果动态导入一个自从解释器开始执行以来被创建的模块（即创建了一个 Python 源代码文件），为了让导入系统知道这个新模块，可能需要调用 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>父包会被自动导入。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.find_loader">
<code class="descclassname">importlib.</code><code class="descname">find_loader</code><span class="sig-paren">(</span><em>name</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>查找一个模块的加载器，可选择地在指定的 <em>path</em> 里面。如果这个模块是在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>，那么返回 <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__loader__</span></code> (除非这个加载器是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或者是没有被设置， 在这样的情况下，会引起 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常）。 否则使用 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 的一次搜索就结束。如果未发现加载器，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>点状的名称没有使得它父包或模块隐式地导入，因为它需要加载它们并且可能不需要。为了适当地导入一个子模块，需要导入子模块的所有父包并且使用正确的参数提供给 <em>path</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果没有设置 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>，会引起 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常，就像属性设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候一样。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.invalidate_caches">
<code class="descclassname">importlib.</code><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>使查找器存储在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 中的内部缓存无效。如果一个查找器实现了 <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code>，那么它会被调用来执行那个无效过程。 如果创建/安装任何模块，同时正在运行的程序是为了保证所有的查找器知道新模块的存在，那么应该调用这个函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.reload">
<code class="descclassname">importlib.</code><code class="descname">reload</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="永久链接至目标">¶</a></dt>
<dd><p>重新加载之前导入的 <em>module</em>。那个参数必须是一个模块对象，所以它之前必须已经成功导入了。这样做是有用的，如果使用外部编辑器编已经辑过了那个模块的源代码文件并且想在退出 Python 解释器之前试验这个新版本的模块。函数的返回值是那个模块对象（如果重新导入导致一个不同的对象放置在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，那么那个模块对象是有可能会不同）。</p>
<p>当执行 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> 的时候：</p>
<ul class="simple">
<li><p>Python 模块的代码会被重新编译并且那个模块级的代码被重新执行，通过重新使用一开始加载那个模块的 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>，定义一个新的绑定在那个模块字典中的名称的对象集合。扩展模块的``init``函数不会被调用第二次。</p></li>
<li><p>与Python中的所有的其它对象一样，旧的对象只有在它们的引用计数为0之后才会被回收。</p></li>
<li><p>模块命名空间中的名称重新指向任何新的或更改后的对象。</p></li>
<li><p>其他旧对象的引用（例如那个模块的外部名称）不会被重新绑定到引用的新对象的，并且如果有需要，必须在出现的每个命名空间中进行更新。</p></li>
</ul>
<p>有一些其他注意事项：</p>
<p>当一个模块被重新加载的时候，它的字典（包含了那个模块的全区变量）会被保留。名称的重新定义会覆盖旧的定义，所以通常来说这不是问题。如果一个新模块没有定义在旧版本模块中定义的名称，则将保留旧版本中的定义。这一特性可用于作为那个模块的优点，如果它维护一个全局表或者对象的缓存 —— 使用 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句，就可以测试表的存在并且跳过它的初始化，如果有需要的话:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>重新加载内置的或者动态加载模块，通常来说不是很有用处。不推荐重新加载&quot;<a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>，<a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>，<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 和其它关键模块。在很多例子中，扩展模块并不是设计为不止一次的初始化，并且当重新加载时，可能会以任意方式失败。</p>
<p>如果一个模块使用 <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ... 导入的对象来自另外一个模块，给其它模块调用 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> 不会重新定义来自这个模块的对象 —— 解决这个问题的一种方式是重新执行 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 语句，另一种方式是使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 和限定名称(<em>module.name</em>)来代替。</p>
<p>如果一个模块创建一个类的实例，重新加载定义那个类的模块不影响那些实例的方法定义———它们继续使用旧类中的定义。对于子类来说同样是正确的。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>当重新加载的那个模块缺少 <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> 的时候，会引起 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 异常。</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> —— 关于导入的抽象基类<a class="headerlink" href="#module-importlib.abc" title="永久链接至标题">¶</a></h2>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p>The <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> module contains all of the core abstract base classes
used by <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>. Some subclasses of the core abstract base classes
are also provided to help in implementing the core ABCs.</p>
<p>ABC 类的层次结构：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="永久链接至目标">¶</a></dt>
<dd><p>代表 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> 的一个抽象基类</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> 或 <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a> 来代替。</p>
</div>
<dl class="method">
<dt id="importlib.abc.Finder.find_module">
<em class="property">abstractmethod </em><code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>为指定的模块查找 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 定义的抽象方法。本来是在 <span class="target" id="index-28"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 指定的，这个方法是在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 和基于路径的导入子系统中使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当被调用的时候，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="永久链接至目标">¶</a></dt>
<dd><p>代表 <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> 的一个抽象基类。 为了保持兼容性，这是 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a> 的一个子类。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>一个为了在指定的模块中查找模块 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">规格</span></a> 而定义的抽象方法。如果这是最高层级导入，<em>path</em> 的值将会是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。否则，这是一个查找子包或者模块的的方法并且 <em>path</em> 将会是来自父包的 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 的值。如果未能查找到一个规格，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。当向这个函数传参时，<code class="docutils literal notranslate"><span class="pre">target</span></code> 是查找器用于做出对返回什么规格更具有根据的猜测的一个模块对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于查找指定的模块中 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的遗留方法。如果这是最高层级的导入，<em>path</em> 的值将会是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。否则，这是一个查找子包或者模块的方法，并且 <em>path</em> 的值将会是来自父包的 <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 的值。如果未发现加载器，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果定义了 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 方法，则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当调用这个方法的时候返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。 可以使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来提供功能。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>当被调用的时候，一个可选的方法应该将查找器使用的任何内部缓存进行无效。将在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 上的所有查找器的缓存进行无效的时候，这个函数被 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a> 所使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当方法被调用的时候，方法返回是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> 的一个抽象基类。尽管这个基类和 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> 有一些相似之处，但是 <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code> 只在由 <code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code> 提供的基于路径导入子系统中使用。这个抽象类是 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> 的一个子类，仅仅是因为兼容性的原因。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>一个为了在指定的模块中查找模块 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">规格</span></a> 而定义的抽象方法。 查找器只会在赋值给 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> 里面查找那个模块。如果未能找到一个规格，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 当向这个函数传参时，<code class="docutils literal notranslate"><span class="pre">target</span></code> 是这个查找器用于做出对于返回什么规格更具有根据的猜测的一个模块对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于在模块中查找一个 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的遗留方法。 返回一个 <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code> 的2元组，<code class="docutils literal notranslate"><span class="pre">portion</span></code> 是一个贡献给命名空间包部分的文件系统位置的序列。 加载器可能是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，同时正在指定的 <code class="docutils literal notranslate"><span class="pre">portion</span></code> 表示的是贡献给命名空间包的文件系统位置。<code class="docutils literal notranslate"><span class="pre">portion</span></code> 可以使用一个空列表来表示加载器不是命名空间包的一部分。 如果 <code class="docutils literal notranslate"><span class="pre">loader</span></code> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 并且 <code class="docutils literal notranslate"><span class="pre">portion</span></code> 是一个空列表，那么命名空间包中无加载器或者文件系统位置可查找到（即在那个模块中未能找到任何东西）。</p>
<p>如果定义了 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> ，则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>返回 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。 当可于提供相应的功能的时候，使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module`的具体实现，该方法等价于``self.find_loader(fullname)[0]`()</span></code>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>当被调用的时候，一个可选的方法应该将查找器使用的任何内部缓存进行无效。当将所有缓存的查找器的缓存进行无效的时候，该函数被  <code class="xref py py-meth docutils literal notranslate"><span class="pre">PathFinder.invalidate_caches()</span></code> 使用。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的抽象基类。 关于一个加载器的实际定义请查看 <span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>。</p>
<p>加载器想要支持资源读取应该实现一个由 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a> 指定的``get_resource_reader(fullname)`` 方法。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>引入了可选的 <code class="docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> 方法。</p>
</div>
<dl class="method">
<dt id="importlib.abc.Loader.create_module">
<code class="descname">create_module</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="永久链接至目标">¶</a></dt>
<dd><p>当导入一个模块的时候，一个返回将要使用的那个模块对象的方法。这个方法可能返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，这暗示着应该发生默认的模块创建语义。&quot;</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>从 Python 3.6 开始，当定义了 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 的时候，这个方法将不会是可选的。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>当一个模块被导入或重新加载时，一个抽象方法在它自己的命名空间中执行那个模块。当调用 <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 的时候，那个模块应该已经被初始化 了。当这个方法存在时，必须定义 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 也必须被定义。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>用于加载一个模块的传统方法。如果这个模块不能被导入，将引起 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常，否则返回那个被加载的模块。</p>
<p>如果请求的模块已经存在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>，应该使用并且重新加载那个模块。 否则加载器应该是创建一个新的模块并且在任何家过程开始之前将这个新模块插入到 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，来阻止递归导入。 如果加载器插入了一个模块并且加载失败了，加载器必须从 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中将这个模块移除。在加载器开始执行之前，已经在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中的模块应该被忽略 (查看 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>)。</p>
<p>加载器应该在模块上面设置几个属性。（要知道当重新加载一个模块的时候，那些属性某部分可以改变）：</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>模块的名字</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>模块数据存储的路径(不是为了内置的模块而设置)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>被存储或应该被存储的模块的编译版本的路径（当这个属性不恰当的时候不设置）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>指定在一个包中搜索路径的一个字符串列表。这个属性不在模块上面进行设置。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>模块/包的父包。如果这个模块是最上层的，那么它是一个为空字符串的值。 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 装饰器可以处理 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 的细节。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>用来加载那个模块的加载器。 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 装饰器可以处理 <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 的细节。</p>
</dd>
</dl>
</li>
</ul>
<p>当 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 可用的时候，那么则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当这个方法被调用的时候，触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。当 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 可用的时候，使用它的功能。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>加载模块推荐的使用的 API 是 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> (和 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>)。 加载器应该实现它而不是 load_module()。 当 exec_module() 被实现的时候，导入机制关心的是 load_module() 所有其他的责任。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.module_repr">
<code class="descname">module_repr</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="永久链接至目标">¶</a></dt>
<dd><p>一个遗留方法，在实现时计算并返回给定模块的 repr，作为字符串。 模块类型的默认 repr() 将根据需要使用此方法的结果。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>是可选的方法而不是一个抽象方法。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>现在导入机制会自动地关注这个方法。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceReader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ResourceReader</code><a class="headerlink" href="#importlib.abc.ResourceReader" title="永久链接至目标">¶</a></dt>
<dd><p>提供读取 <em>resources</em> 能力的一个 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> 。</p>
<p>从这个 ABC 的视角出发，<em>resource</em> 指一个包附带的二进制文件。常见的如在包的  <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件旁的数据文件。这个类存在的目的是为了将对数据文件的访问进行抽象，这样包就和其数据文件的存储方式无关了。不论这些文件是存放在一个 zip 文件里还是直接在文件系统内。</p>
<p>对于该类中的任一方法，<em>resource</em> 参数的值都需要是一个在概念上表示文件名称的 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。 这意味着任何子目录的路径都不该出现在 <em>resouce</em> 参数值内。 因为对于阅读器而言，包的位置就代表着「目录」。 因此目录和文件名就分别对应于包和资源。 这也是该类的实例都需要和一个包直接关联（而不是潜在指代很多包或者一整个模块）的原因。</p>
<p>加载 resource 的各类加载器需要提供一个名为 <code class="docutils literal notranslate"><span class="pre">get_resource_loader(fullname)</span></code> 的方法以返回一个视线了改抽象基类接口的对象。如果 fullname 参数指定的模块不是一个包，该方法应返回 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。只有在指定模块是一个包的情况下，该方法才应当返回一个和该抽象基类兼容的对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceReader.open_resource">
<em class="property">abstractmethod </em><code class="descname">open_resource</code><span class="sig-paren">(</span><em>resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个打开的 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> 用于 <em>resource</em> 的二进制读取。</p>
<p>如果无法找到资源，将会引发 <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.resource_path">
<em class="property">abstractmethod </em><code class="descname">resource_path</code><span class="sig-paren">(</span><em>resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>resource</em> 的文件系统路径。</p>
<p>如果资源并不实际存在于文件系统中，将会引发 <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.is_resource">
<em class="property">abstractmethod </em><code class="descname">is_resource</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the named <em>name</em> is considered a resource.
<a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> is raised if <em>name</em> does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.ResourceReader.contents">
<em class="property">abstractmethod </em><code class="descname">contents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="永久链接至目标">¶</a></dt>
<dd><p>Returns an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> of strings over the contents of
the package. Do note that it is not required that all names
returned by the iterator be actual resources, e.g. it is
acceptable to return names for which <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a> would
be false.</p>
<p>Allowing non-resource names to be returned is to allow for
situations where how a package and its resources are stored
are known a priori and the non-resource names would be useful.
For instance, returning subdirectory names is allowed so that
when it is known that the package and resources are stored on
the file system then those subdirectory names can be used
directly.</p>
<p>这个抽象方法返回了一个不包含任何内容的可迭代对象。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class for a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> which implements the optional
<span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol for loading arbitrary resources from the storage
back-end.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.7 版后已移除: </span>由于要支持使用 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>  类来加载资源，这个 ABC 已经被弃用了。</p>
</div>
<dl class="method">
<dt id="importlib.abc.ResourceLoader.get_data">
<em class="property">abstractmethod </em><code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract method to return the bytes for the data located at <em>path</em>.
Loaders that have a file-like storage back-end
that allows storing arbitrary data
can implement this abstract method to give direct access
to the data stored. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> is to be raised if the <em>path</em> cannot
be found. The <em>path</em> is expected to be constructed using a module's
<a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> attribute or an item from a package's <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raises <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class for a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> which implements the optional
<span class="target" id="index-15"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol for loaders that inspect modules.</p>
<dl class="method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>Return the code object for a module, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the module does not
have a code object (as would be the case, for example, for a built-in
module).  Raise an <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> if loader cannot find the
requested module.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>While the method has a default implementation, it is suggested that
it be overridden if possible for performance.</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">在 3.4 版更改: </span>No longer abstract and a concrete implementation is provided.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.get_source">
<em class="property">abstractmethod </em><code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract method to return the source of a module. It is returned as
a text string using <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>, translating all
recognized line separators into <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> characters.  Returns <code class="docutils literal notranslate"><span class="pre">None</span></code>
if no source is available (e.g. a built-in module). Raises
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> if the loader cannot find the module specified.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract method to return a true value if the module is a package, a
false value otherwise. <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised if the
<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> cannot find the module.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="importlib.abc.InspectLoader.source_to_code">
<em class="property">static </em><code class="descname">source_to_code</code><span class="sig-paren">(</span><em>data</em>, <em>path='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="永久链接至目标">¶</a></dt>
<dd><p>Create a code object from Python source.</p>
<p>The <em>data</em> argument can be whatever the <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> function
supports (i.e. string or bytes). The <em>path</em> argument should be
the &quot;path&quot; to where the source code originated from, which can be an
abstract concept (e.g. location in a zip file).</p>
<p>With the subsequent code object one can execute it in a module by
running <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>Made the method static.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>Implementation of <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>Implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>use <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class which inherits from <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> that,
when implemented, helps a module to be executed as a script. The ABC
represents an optional <span class="target" id="index-17"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> protocol.</p>
<dl class="method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<em class="property">abstractmethod </em><code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract method that is to return the value of <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> for
the specified module. If no path is available, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is
raised.</p>
<p>If source code is available, then the method should return the path to
the source file, regardless of whether a bytecode was used to load the
module.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raises <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">FileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class which inherits from <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> and
<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, providing concrete implementations of
<a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a> and <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>.</p>
<p>The <em>fullname</em> argument is a fully resolved name of the module the loader is
to handle. The <em>path</em> argument is the path to the file for the module.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the module the loader can handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>Path to the file of the module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>Calls super's <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>Use <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_filename">
<em class="property">abstractmethod </em><code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_data">
<em class="property">abstractmethod </em><code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="永久链接至目标">¶</a></dt>
<dd><p>Reads <em>path</em> as a binary file and returns the bytes from it.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class for implementing source (and optionally bytecode)
file loading. The class inherits from both <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> and
<a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, requiring the implementation of:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>Should only return the path to the source file; sourceless
loading is not supported.</p>
</dd>
</dl>
</li>
</ul>
<p>The abstract methods defined by this class are to add optional bytecode
file support. Not implementing these optional methods (or causing them to
raise <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>) causes the loader to
only work with source code. Implementing the methods allows the loader to
work with source <em>and</em> bytecode files; it does not allow for <em>sourceless</em>
loading where only bytecode is provided.  Bytecode files are an
optimization to speed up loading by removing the parsing step of Python's
compiler, and so no bytecode-specific API is exposed.</p>
<dl class="method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="永久链接至目标">¶</a></dt>
<dd><p>Optional abstract method which returns a <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> containing
metadata about the specified path.  Supported dictionary keys are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (mandatory): an integer or floating-point number
representing the modification time of the source code;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (optional): the size in bytes of the source code.</p></li>
</ul>
<p>Any other keys in the dictionary are ignored, to allow for future
extensions. If the path cannot be handled, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="descname">path_mtime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="永久链接至目标">¶</a></dt>
<dd><p>Optional abstract method which returns the modification time for the
specified path.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>This method is deprecated in favour of <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>.  You don't
have to implement it, but it is still available for compatibility
purposes. Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> if the path cannot be handled.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> instead of <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="永久链接至目标">¶</a></dt>
<dd><p>Optional abstract method which writes the specified bytes to a file
path. Any intermediate directories which do not exist are to be created
automatically.</p>
<p>When writing to the path fails because the path is read-only
(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>), do not propagate the
exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>No longer raises <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> when called.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>Use <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>. A module
is determined to be a package if its file path (as provided by
<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>) is a file named
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> when the file extension is removed <strong>and</strong> the module name
itself does not end in <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.resources">
<span id="importlib-resources-resources"></span><h2><a class="reference internal" href="#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> -- Resources<a class="headerlink" href="#module-importlib.resources" title="永久链接至标题">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/importlib/resources.py">Lib/importlib/resources.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
<p>This module leverages Python's import system to provide access to <em>resources</em>
within <em>packages</em>.  If you can import a package, you can access resources
within that package.  Resources can be opened or read, in either binary or
text mode.</p>
<p>Resources are roughly akin to files inside directories, though it's important
to keep in mind that this is just a metaphor.  Resources and packages <strong>do
not</strong> have to exist as physical files and directories on the file system.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>This module provides functionality similar to <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a> <a class="reference external" href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Basic
Resource Access</a>
without the performance overhead of that package.  This makes reading
resources included in packages easier, with more stable and consistent
semantics.</p>
<p>The standalone backport of this module provides more information
on <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/using.html">using importlib.resources</a> and
<a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/migration.html">migrating from pkg_resources to importlib.resources</a>.</p>
</div>
<p>加载器想要支持资源读取应该实现一个由 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a> 指定的``get_resource_reader(fullname)`` 方法。</p>
<p>The following types are defined.</p>
<dl class="data">
<dt id="importlib.resources.Package">
<code class="descclassname">importlib.resources.</code><code class="descname">Package</code><a class="headerlink" href="#importlib.resources.Package" title="永久链接至目标">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">Package</span></code> type is defined as <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">ModuleType]</span></code>.  This means
that where the function describes accepting a <code class="docutils literal notranslate"><span class="pre">Package</span></code>, you can pass in
either a string or a module.  Module objects must have a resolvable
<code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code> that is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="data">
<dt id="importlib.resources.Resource">
<code class="descclassname">importlib.resources.</code><code class="descname">Resource</code><a class="headerlink" href="#importlib.resources.Resource" title="永久链接至目标">¶</a></dt>
<dd><p>This type describes the resource names passed into the various functions
in this package.  This is defined as <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">os.PathLike]</span></code>.</p>
</dd></dl>

<p>The following functions are available.</p>
<dl class="function">
<dt id="importlib.resources.open_binary">
<code class="descclassname">importlib.resources.</code><code class="descname">open_binary</code><span class="sig-paren">(</span><em>package</em>, <em>resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_binary" title="永久链接至目标">¶</a></dt>
<dd><p>Open for binary reading the <em>resource</em> within <em>package</em>.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns a
<code class="docutils literal notranslate"><span class="pre">typing.BinaryIO</span></code> instance, a binary I/O stream open for reading.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.open_text">
<code class="descclassname">importlib.resources.</code><code class="descname">open_text</code><span class="sig-paren">(</span><em>package</em>, <em>resource</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_text" title="永久链接至目标">¶</a></dt>
<dd><p>Open for text reading the <em>resource</em> within <em>package</em>.  By default, the
resource is opened for reading as UTF-8.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  <em>encoding</em> and <em>errors</em>
have the same meaning as with built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
<p>This function returns a <code class="docutils literal notranslate"><span class="pre">typing.TextIO</span></code> instance, a text I/O stream open
for reading.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_binary">
<code class="descclassname">importlib.resources.</code><code class="descname">read_binary</code><span class="sig-paren">(</span><em>package</em>, <em>resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_binary" title="永久链接至目标">¶</a></dt>
<dd><p>Read and return the contents of the <em>resource</em> within <em>package</em> as
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns the
contents of the resource as <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.read_text">
<code class="descclassname">importlib.resources.</code><code class="descname">read_text</code><span class="sig-paren">(</span><em>package</em>, <em>resource</em>, <em>encoding='utf-8'</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_text" title="永久链接至目标">¶</a></dt>
<dd><p>Read and return the contents of <em>resource</em> within <em>package</em> as a <code class="docutils literal notranslate"><span class="pre">str</span></code>.
By default, the contents are read as strict UTF-8.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  <em>encoding</em> and <em>errors</em>
have the same meaning as with built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.  This function
returns the contents of the resource as <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.path">
<code class="descclassname">importlib.resources.</code><code class="descname">path</code><span class="sig-paren">(</span><em>package</em>, <em>resource</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.path" title="永久链接至目标">¶</a></dt>
<dd><p>Return the path to the <em>resource</em> as an actual file system path.  This
function returns a context manager for use in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.
The context manager provides a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> object.</p>
<p>Exiting the context manager cleans up any temporary file created when the
resource needs to be extracted from e.g. a zip file.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.  <em>resource</em> is the name of the resource to open
within <em>package</em>; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.is_resource">
<code class="descclassname">importlib.resources.</code><code class="descname">is_resource</code><span class="sig-paren">(</span><em>package</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.is_resource" title="永久链接至目标">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if there is a resource named <em>name</em> in the package,
otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.  Remember that directories are <em>not</em> resources!
<em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.</p>
</dd></dl>

<dl class="function">
<dt id="importlib.resources.contents">
<code class="descclassname">importlib.resources.</code><code class="descname">contents</code><span class="sig-paren">(</span><em>package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.contents" title="永久链接至目标">¶</a></dt>
<dd><p>Return an iterable over the named items within the package.  The iterable
returns <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> resources (e.g. files) and non-resources
(e.g. directories).  The iterable does not recurse into subdirectories.</p>
<p><em>package</em> is either a name or a module object which conforms to the
<code class="docutils literal notranslate"><span class="pre">Package</span></code> requirements.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> -- Importers and path hooks<a class="headerlink" href="#module-importlib.machinery" title="永久链接至标题">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>This module contains the various objects that help <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>
find and load modules.</p>
<dl class="attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for source
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>A list of strings representing the file suffixes for non-optimized bytecode
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.5 版后已移除: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>A list of strings representing the file suffixes for optimized bytecode
modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.5 版后已移除: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for bytecode
modules (including the leading dot).</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>The value is no longer dependent on <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>A list of strings representing the recognized file suffixes for
extension modules.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.machinery.all_suffixes">
<code class="descclassname">importlib.machinery.</code><code class="descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="永久链接至目标">¶</a></dt>
<dd><p>Returns a combined list of strings representing all file suffixes for
modules recognized by the standard import machinery. This is a
helper for code which simply needs to know if a filesystem path
potentially refers to a module without needing any details on the kind
of module (for example, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="永久链接至目标">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> for built-in modules. All known built-in modules are
listed in <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>. This class implements the
<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> and
<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>As part of <span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>, the builtin importer now implements
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="永久链接至目标">¶</a></dt>
<dd><p>An <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> for frozen modules. This class implements the
<a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> and
<a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABCs.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> for modules declared in the Windows registry.  This class
implements the <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>Use <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> configuration instead. Future versions of Python may
not enable this finder by default.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> for <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> and package <code class="docutils literal notranslate"><span class="pre">__path__</span></code> attributes.
This class implements the <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Only class methods are defined by this class to alleviate the need for
instantiation.</p>
<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>Class method that attempts to find a <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>
for the module specified by <em>fullname</em> on <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> or, if
defined, on <em>path</em>. For each path entry that is searched,
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> is checked. If a non-false object
is found then it is used as the <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> to look
for the module being searched for. If no entry is found in
<a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, then <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> is
searched for a finder for the path entry and, if found, is stored
in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> along with being queried about
the module. If no finder is ever found then <code class="docutils literal notranslate"><span class="pre">None</span></code> is both
stored in the cache and returned.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>If the current working directory -- represented by an empty string --
is no longer valid then <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned but no value is cached
in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>A legacy wrapper around <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>Calls <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> on all
finders stored in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> that define the method.
Otherwise entries in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> set to <code class="docutils literal notranslate"><span class="pre">None</span></code> are
deleted.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>Entries of <code class="docutils literal notranslate"><span class="pre">None</span></code> in <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> are deleted.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Calls objects in <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> with the current working
directory for <code class="docutils literal notranslate"><span class="pre">''</span></code> (i.e. the empty string).</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FileFinder</code><span class="sig-paren">(</span><em>path</em>, <em>*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="永久链接至目标">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> which
caches results from the file system.</p>
<p>The <em>path</em> argument is the directory for which the finder is in charge of
searching.</p>
<p>The <em>loader_details</em> argument is a variable number of 2-item tuples each
containing a loader and a sequence of file suffixes the loader recognizes.
The loaders are expected to be callables which accept two arguments of
the module's name and the path to the file found.</p>
<p>The finder will cache the directory contents as necessary, making stat calls
for each module search to verify the cache is not outdated. Because cache
staleness relies upon the granularity of the operating system's state
information of the file system, there is a potential race condition of
searching for a module, creating a new file, and then searching for the
module the new file represents. If the operations happen fast enough to fit
within the granularity of stat calls, then the module search will fail. To
prevent this from happening, when you create a module dynamically, make sure
to call <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="永久链接至目标">¶</a></dt>
<dd><p>The path the finder will search in.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>Attempt to find the spec to handle <em>fullname</em> within <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>Attempt to find the loader to handle <em>fullname</em> within <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>Clear out the internal cache.</p>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="descname">path_hook</code><span class="sig-paren">(</span><em>*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="永久链接至目标">¶</a></dt>
<dd><p>A class method which returns a closure for use on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.
An instance of <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> is returned by the closure using the
path argument given to the closure directly and <em>loader_details</em>
indirectly.</p>
<p>If the argument to the closure is not an existing directory,
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourceFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> by
subclassing <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> and providing some concrete
implementations of other methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the module that this loader will handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>The path to the source file.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>Return true if <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> appears to be for a package.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>Use <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> which can
import bytecode files (i.e. no source code files exist).</p>
<p>Please note that direct use of bytecode files (and thus not source code
files) inhibits your modules from being usable by all Python
implementations or new versions of Python which change the bytecode
format.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>The name of the module the loader will handle.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>The path to the bytecode file.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>Determines if the module is a package based on <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>Returns the code object for <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> created from <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as bytecode files have no source when this loader is
used.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>Use <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p>A concrete implementation of <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> for
extension modules.</p>
<p>The <em>fullname</em> argument specifies the name of the module the loader is to
support. The <em>path</em> argument is the path to the extension module's file.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>Name of the module the loader supports.</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>Path to the extension module.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.create_module">
<code class="descname">create_module</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="永久链接至目标">¶</a></dt>
<dd><p>Creates the module object from the given specification in accordance
with <span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>Initializes the given module object in accordance with <span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the file path points to a package's <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
module based on <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as extension modules lack a code object.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> as extension modules do not have source code.</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>Returns <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ModuleSpec</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>loader_state=None</em>, <em>is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="永久链接至目标">¶</a></dt>
<dd><p>A specification for a module's import-system-related state.  This is
typically exposed as the module's <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> attribute.  In the
descriptions below, the names in parentheses give the corresponding
attribute available directly on the module object.
E.g. <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>.  Note however that
while the <em>values</em> are usually equivalent, they can differ since there is
no synchronization between the two objects.  Thus it is possible to update
the module's <code class="docutils literal notranslate"><span class="pre">__path__</span></code> at runtime, and this will not be automatically
reflected in <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__name__</span></code>)</p>
<p>A string for the fully-qualified name of the module.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>)</p>
<p>The loader to use for loading.  For namespace packages this should be
set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__file__</span></code>)</p>
<p>Name of the place from which the module is loaded, e.g. &quot;builtin&quot; for
built-in modules and the filename for modules loaded from source.
Normally &quot;origin&quot; should be set, but it may be <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default)
which indicates it is unspecified (e.g. for namespace packages).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__path__</span></code>)</p>
<p>List of strings for where to find submodules, if a package (<code class="docutils literal notranslate"><span class="pre">None</span></code>
otherwise).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Container of extra module-specific data for use during loading (or
<code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__cached__</span></code>)</p>
<p>String for where the compiled module should be stored (or <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__package__</span></code>)</p>
<p>(Read-only) Fully-qualified name of the package to which the module
belongs as a submodule (or <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>Boolean indicating whether or not the module's &quot;origin&quot;
attribute refers to a loadable location.</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> -- Utility code for importers<a class="headerlink" href="#module-importlib.util" title="永久链接至标题">¶</a></h2>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>This module contains the various objects that help in the construction of
an <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>.</p>
<dl class="attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="descclassname">importlib.util.</code><code class="descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="永久链接至目标">¶</a></dt>
<dd><p>The bytes which represent the bytecode version number. If you need help with
loading/writing bytecode then consider <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.cache_from_source">
<code class="descclassname">importlib.util.</code><code class="descname">cache_from_source</code><span class="sig-paren">(</span><em>path</em>, <em>debug_override=None</em>, <em>*</em>, <em>optimization=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="永久链接至目标">¶</a></dt>
<dd><p>Return the <span class="target" id="index-21"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-22"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> path to the byte-compiled file associated
with the source <em>path</em>.  For example, if <em>path</em> is <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> the return
value would be <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> for Python 3.2.
The <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> string comes from the current magic tag (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; if <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> is not defined then
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> will be raised).</p>
<p>The <em>optimization</em> parameter is used to specify the optimization level of the
bytecode file. An empty string represents no optimization, so
<code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> with an <em>optimization</em> of <code class="docutils literal notranslate"><span class="pre">''</span></code> will result in a
bytecode path of <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> causes
the interpter's optimization level to be used. Any other value's string
representation being used, so <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> with an <em>optimization</em> of
<code class="docutils literal notranslate"><span class="pre">2</span></code> will lead to the bytecode path of
<code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>. The string representation
of <em>optimization</em> can only be alphanumeric, else <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>The <em>debug_override</em> parameter is deprecated and can be used to override
the system's value for <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>. A <code class="docutils literal notranslate"><span class="pre">True</span></code> value is the equivalent of
setting <em>optimization</em> to the empty string. A <code class="docutils literal notranslate"><span class="pre">False</span></code> value is the same as
setting <em>optimization</em> to <code class="docutils literal notranslate"><span class="pre">1</span></code>. If both <em>debug_override</em> an <em>optimization</em>
are not <code class="docutils literal notranslate"><span class="pre">None</span></code> then <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>The <em>optimization</em> parameter was added and the <em>debug_override</em> parameter
was deprecated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">类路径对象</span></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_from_cache">
<code class="descclassname">importlib.util.</code><code class="descname">source_from_cache</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="永久链接至目标">¶</a></dt>
<dd><p>Given the <em>path</em> to a <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> file name, return the associated source code
file path.  For example, if <em>path</em> is
<code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> the returned path would be
<code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>.  <em>path</em> need not exist, however if it does not conform
to <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> or <span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> format, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised. If
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> is not defined,
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> is raised.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">类路径对象</span></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.decode_source">
<code class="descclassname">importlib.util.</code><code class="descname">decode_source</code><span class="sig-paren">(</span><em>source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="永久链接至目标">¶</a></dt>
<dd><p>Decode the given bytes representing source code and return it as a string
with universal newlines (as required by
<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.resolve_name">
<code class="descclassname">importlib.util.</code><code class="descname">resolve_name</code><span class="sig-paren">(</span><em>name</em>, <em>package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="永久链接至目标">¶</a></dt>
<dd><p>Resolve a relative module name to an absolute one.</p>
<p>If  <strong>name</strong> has no leading dots, then <strong>name</strong> is simply returned. This
allows for usage such as
<code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__package__)</span></code> without doing a
check to see if the <strong>package</strong> argument is needed.</p>
<p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if <strong>name</strong> is a relative module name but
package is a false value (e.g. <code class="docutils literal notranslate"><span class="pre">None</span></code> or the empty string).
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is also raised a relative name would escape its containing
package (e.g. requesting <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> from within the <code class="docutils literal notranslate"><span class="pre">spam</span></code> package).</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.find_spec">
<code class="descclassname">importlib.util.</code><code class="descname">find_spec</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>Find the <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for a module, optionally relative to
the specified <strong>package</strong> name. If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>,
then <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be
<code class="docutils literal notranslate"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised).
Otherwise a search using <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> is done. <code class="docutils literal notranslate"><span class="pre">None</span></code> is
returned if no spec is found.</p>
<p>If <strong>name</strong> is for a submodule (contains a dot), the parent module is
automatically imported.</p>
<p><strong>name</strong> and <strong>package</strong> work the same as for <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>Raises <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> instead of <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> if
<strong>package</strong> is in fact not a package (i.e. lacks a <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>
attribute).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_from_spec">
<code class="descclassname">importlib.util.</code><code class="descname">module_from_spec</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="永久链接至目标">¶</a></dt>
<dd><p>Create a new module based on <strong>spec</strong> and
<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>.</p>
<p>If <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>
does not return <code class="docutils literal notranslate"><span class="pre">None</span></code>, then any pre-existing attributes will not be reset.
Also, no <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> will be raised if triggered while accessing
<strong>spec</strong> or setting an attribute on the module.</p>
<p>This function is preferred over using <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> to create a
new module as <strong>spec</strong> is used to set as many import-controlled attributes on
the module as possible.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_for_loader">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>
to handle selecting the proper
module object to load with. The decorated method is expected to have a call
signature taking two positional arguments
(e.g. <code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) for which the second argument
will be the module <strong>object</strong> to be used by the loader.
Note that the decorator will not work on static methods because of the
assumption of two arguments.</p>
<p>The decorated method will take in the <strong>name</strong> of the module to be loaded
as expected for a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. If the module is not found in
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> then a new one is constructed. Regardless of where the
module came from, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> set to <strong>self</strong> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
is set based on what <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> returns
(if available). These attributes are set unconditionally to support
reloading.</p>
<p>If an exception is raised by the decorated method and a module was added to
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, then the module will be removed to prevent a partially
initialized module from being in left in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. If the module
was already in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> then it is left alone.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> are automatically set
(when possible).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Set <a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
unconditionally to support reloading.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>The import machinery now directly performs all the functionality
provided by this function.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_loader">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>
to set the <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>
attribute on the returned module. If the attribute is already set the
decorator does nothing. It is assumed that the first positional argument to
the wrapped method (i.e. <code class="docutils literal notranslate"><span class="pre">self</span></code>) is what <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> should be set
to.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>Set <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> if set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, as if the attribute does not
exist.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>The import machinery takes care of this automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_package">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="永久链接至目标">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> to set the
<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> attribute on the returned module. If <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>
is set and has a value other than <code class="docutils literal notranslate"><span class="pre">None</span></code> it will not be changed.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>The import machinery takes care of this automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_loader">
<code class="descclassname">importlib.util.</code><code class="descname">spec_from_loader</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="永久链接至目标">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> instance based
on a loader.  The parameters have the same meaning as they do for
ModuleSpec.  The function uses available <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> APIs, such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, to fill in any missing
information on the spec.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_file_location">
<code class="descclassname">importlib.util.</code><code class="descname">spec_from_file_location</code><span class="sig-paren">(</span><em>name</em>, <em>location</em>, <em>*</em>, <em>loader=None</em>, <em>submodule_search_locations=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="永久链接至目标">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code> instance based
on the path to a file.  Missing information will be filled in on the
spec by making use of loader APIs and by the implication that the
module will be file-based.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">类路径对象</span></a>。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_hash">
<code class="descclassname">importlib.util.</code><code class="descname">source_hash</code><span class="sig-paren">(</span><em>source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="永久链接至目标">¶</a></dt>
<dd><p>Return the hash of <em>source_bytes</em> as bytes. A hash-based <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> file embeds
the <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a> of the corresponding source file's contents in its
header.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.util.LazyLoader">
<em class="property">class </em><code class="descclassname">importlib.util.</code><code class="descname">LazyLoader</code><span class="sig-paren">(</span><em>loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="永久链接至目标">¶</a></dt>
<dd><p>A class which postpones the execution of the loader of a module until the
module has an attribute accessed.</p>
<p>This class <strong>only</strong> works with loaders that define
<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> as control over what module type
is used for the module is required. For those same reasons, the loader's
<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> method must return <code class="docutils literal notranslate"><span class="pre">None</span></code> or a
type for which its <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute can be mutated along with not
using <a class="reference internal" href="../glossary.html#term-slots"><span class="xref std std-term">slots</span></a>. Finally, modules which substitute the object
placed into <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> will not work as there is no way to properly
replace the module references throughout the interpreter safely;
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if such a substitution is detected.</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>For projects where startup time is critical, this class allows for
potentially minimizing the cost of loading a module if it is never used.
For projects where startup time is not essential then use of this class is
<strong>heavily</strong> discouraged due to error messages created during loading being
postponed and thus occurring out of context.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>Began calling <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>, removing the
compatibility warning for <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> and
<a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a>.</p>
</div>
<dl class="classmethod">
<dt id="importlib.util.LazyLoader.factory">
<em class="property">classmethod </em><code class="descname">factory</code><span class="sig-paren">(</span><em>loader</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="永久链接至目标">¶</a></dt>
<dd><p>A static method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="examples">
<span id="importlib-examples"></span><h2>示例<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h2>
<div class="section" id="importing-programmatically">
<h3>Importing programmatically<a class="headerlink" href="#importing-programmatically" title="永久链接至标题">¶</a></h3>
<p>To programmatically import a module, use <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-if-a-module-can-be-imported">
<h3>Checking if a module can be imported<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="永久链接至标题">¶</a></h3>
<p>If you need to find out if a module can be imported without actually doing the
import, then you should use <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;can&#39;t find the itertools module&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="c1"># Adding the module to sys.modules is optional.</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
</pre></div>
</div>
</div>
<div class="section" id="importing-a-source-file-directly">
<h3>Importing a source file directly<a class="headerlink" href="#importing-a-source-file-directly" title="永久链接至标题">¶</a></h3>
<p>To import a Python source file directly, use the following recipe
(Python 3.5 and newer only):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="c1"># Optional; only necessary if you want to be able to import the module</span>
<span class="c1"># by name later.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-an-importer">
<h3>Setting up an importer<a class="headerlink" href="#setting-up-an-importer" title="永久链接至标题">¶</a></h3>
<p>For deep customizations of import, you typically want to implement an
<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>. This means managing both the <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> and <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>
side of things. For finders there are two flavours to choose from depending on
your needs: a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> or a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. The
former is what you would put on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> while the latter is what
you create using a <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> which works
with <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path</span></code></a> entries to potentially create a finder. This example will
show you how to register your own importers so that import will use them (for
creating an importer for yourself, read the documentation for the appropriate
classes defined within this package):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="approximating-importlib-import-module">
<h3>Approximating <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a><a class="headerlink" href="#approximating-importlib-import-module" title="永久链接至标题">¶</a></h3>
<p>Import itself is implemented in Python code, making it possible to
expose most of the import machinery through importlib. The following
helps illustrate the various APIs that importlib exposes by providing an
approximate implementation of
<a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> (Python 3.4 and newer for the importlib usage,
Python 3.6 and newer for other parts of the code).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;No module named </span><span class="si">{absolute_name!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="n">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> —— 关于导入的抽象基类</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> -- Resources</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> -- Importers and path hooks</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> -- Utility code for importers</a></li>
<li><a class="reference internal" href="#examples">示例</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importing programmatically</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Checking if a module can be imported</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importing a source file directly</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Setting up an importer</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Approximating <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="runpy.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> --- Locating and executing Python modules</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="language.html"
                        title="下一章">Python 语言服务</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.7/Doc/library/importlib.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="language.html" title="Python 语言服务"
             >下一页</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy --- Locating and executing Python modules"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">zh_CN</span>
          <span class="version_switcher_placeholder">3.7.3</span>
          <a href="../index.html">文档</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >导入模块</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2019, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    最后更新于 5月 30, 2019.
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>2.0.1 创建。
    </div>

  </body>
</html>